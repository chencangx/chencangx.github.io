<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title></title>
    <url>%2F2018%2F04%2F17%2Fmine%2Finterview%2Ftitle%2F</url>
    <content type="text"><![CDATA[title一、HtmlHTML5 新特性，语义化浏览器的标准模式和怪异模式xhtml 和 html 的区别使用 data-的好处meta 标签canvasHTML 废弃的标签css js 放置位置和原因什么是渐进式渲染html 模板语言meta viewport 原理二、CSS盒模型，box-sizingCSS3 新特性，伪类，伪元素，锚伪类CSS 实现隐藏页面的方式如何实现水平居中和垂直居中。说说 position，display请解释*{box-sizing:border-box;}的作用，并说明使用它的好处浮动元素引起的问题和解决办法?绝对定位和相对定位，元素浮动后的 display 值link 和@import 引入 css 的区别解释一下 css3 的 flexbox，以及适用场景inline 和 inline-block 的区别哪些是块级元素那些是行级元素，各有什么特点grid 布局table 布局的作用实现两栏布局有哪些方法?css dpi你知道 attribute 和 property 的区别么css 布局问题?css 实现三列布局怎么做?如果中间是自适应又怎么做?流式布局如何实现，响应式布局如何实现移动端布局方案实现三栏布局(圣杯布局，双飞翼布局，flex 布局)清除浮动的原理overflow:hidden 有什么缺点?padding 百分比是相对于父级宽度还是自身的宽度css3 动画，transition 和 animation 的区别，animation 的属性，加速度，重力的模拟实现CSS 3 如何实现旋转图片(transform: rotate)sass less对移动端开发了解多少?(响应式设计、Zepto;@media、viewport、 JavaScript 正则表达式判断平台。)什么是 bfc，如何创建 bfc?解决什么问题?CSS 中的长度单位(px,pt,rem,em,ex,vw,vh,vh,vmin,vmax)CSS 选择器的优先级是怎样的?雪碧图svg媒体查询的原理是什么?CSS 的加载是异步的吗?表现在什么地方?常遇到的浏览器兼容性问题有哪些?常用的 hack 的技巧外边距合并解释一下”::before”和”:after”中的双冒号和单冒号的区别三、JavaScriptjs 的基本类型有哪些?引用类型有哪些?null 和 undefined 的区别。Object 是引用类型嘛?引用类型和基本类型有什么区别?哪个是存在堆哪一个是存在栈上面的?JS 常见的 dom 操作 api解释一下事件冒泡和事件捕获事件委托(手写例子)，事件冒泡和捕获，如何阻止冒泡?如何组织默认事 件?对闭包的理解?什么时候构成闭包?闭包的实现方法?闭包的优缺点?this 有哪些使用场景?跟 C,Java 中的 this 有什么区别?如何改变 this 的值?call，apply，bind显示原型和隐式原型，手绘原型链，原型链是什么?为什么要有原型链创建对象的多种方式实现继承的多种方式和优缺点new 一个对象具体做了什么手写 Ajax，XMLHttpRequest变量提升举例说明一个匿名函数的典型用例指出 JS 的宿主对象和原生对象的区别，为什么扩展 JS 内置对象不是好的做法?有哪些内置对象和内置函数?attribute 和 property 的区别document load 和 document DOMContentLoaded 两个事件的区别=== 和 == , [] === [], undefined === undefined,[] == [], undefined== undefinedtypeof 能够得到哪些值什么是”use strict”,好处和坏处函数的作用域是什么?js 的作用域有几种?JS 如何实现重载和多态常用的数组 api，字符串 api原生事件绑定(跨浏览器)，dom0 和 dom2 的区别?给定一个元素获取它相对于视图窗口的坐标如何实现图片滚动懒加载js 的字符串类型有哪些方法? 正则表达式的函数怎么使用?深拷贝编写一个通用的事件监听函数web 端 cookie 的设置和获取setTimeout 和 promise 的执行顺序JavaScript 的事件流模型都有什么?navigator 对象，location 和 historyjs 的垃圾回收机制内存泄漏的原因和场景DOM 事件的绑定的几种方式DOM 事件中 target 和 currentTarget 的区别typeof 和 instanceof 区别，instanceof 原理js 动画和 css3 动画比较JavaScript 倒计时(setTimeout)js 处理异常js 的设计模式知道那些轮播图的实现，以及轮播图组件开发，轮播 10000 张图片过程websocket 的工作原理和机制。手指点击可以触控的屏幕时，是什么事件? 什么是函数柯里化?以及说一下 JS 的 API 有哪些应用到了函数柯里化的实现?(函数柯里化一些了解，以及在 函数式编程的应用，- 最后说了一下 JS 中 bind 函数和数组的 reduce 方法用 到了函数柯里化。)JS 代码调试四、ES6谈一谈 promise所有的 ES6 特性你都知道吗?如果遇到一个东西不知道是 ES6 还是 ES5, 你该怎么区分它es6 的继承和 es5 的继承有什么区别promise 封装 ajaxlet const 的优点es6 generator 是什么，async/await 实现原理ES6 和 node 的 commonjs 模块化规范区别箭头函数，以及它的 this五、计算机网络HTTP 协议头含有哪些重要的部分，HTTP 状态码网络 url 输入到输出怎么做?性能优化为什么要减少 HTTP 访问次数?Http 请求的过程与原理https(对是 https)有几次握手和挥手?https 的原理。http 有几次挥手和握手?TLS 的中文名?TLS 在哪一网络层?TCP 连接的特点，TCP 连接如何保证安全可靠的?为什么 TCP 连接需要三次握手，两次不可以吗，为什么为什么 tcp 要三次握手四次挥手?tcp 的三次握手和四次挥手画图(当场画写 ack 和 seq 的值)?tcp 与 udp 的区别get 和 post 的区别?什么情况下用到?http2 与 http1 的区别?websocket什么是 tcp 流，什么是 http 流babel 是如何将 es6 代码编译成 es5 的http2 的持久连接和管线化域名解析时是 tcp 还是 udp域名发散和域名收敛Post 一个 file 的时候 file 放在哪的?HTTP Response 的 Header 里面都有些啥?六、浏览器相关跨域，为什么 JS 会对跨域做出限制前端安全:xss，csrf…浏览器怎么加载页面的?script 脚本阻塞有什么解决方法?defer 和 async 的 区别?浏览器强缓存和协商缓存浏览器的全局变量有哪些浏览器同一时间能够从一个域名下载多少资源按需加载，不同页面的元素判断标准web 存储、cookies、localstroge 等的使用和区别浏览器的内核如何实现缓存机制?(从 200 缓存，到 cache 到 etag 再到)说一下 200 和 304 的理解和区别什么是预加载、懒加载一个 XMLHttpRequest 实例有多少种状态?dns 解析原理，输入网址后如何查找服务器服务器如何知道你?浏览器渲染过程ie 的某些兼容性问题session拖拽实现拆解 url 的各部分七、工程化对 webpack,gulp，grunt 等有没有了解?对比。webpack 的入口文件怎么配置，多个入口怎么分割。webpack 的 loader 和 plugins 的区别gulp 的具体使用。前端工程化的理解、如何自己实现一个文件打包，比如一个 JS 文件里同时又ES5 和 ES6 写的代码，如何编译兼容他们八、模块化对 AMD,CMD,CommonJS 有没有了解?为什么要模块化?不用的时候和用 RequireJs 的时候代码大概怎么写?说说有哪些模块化的库，有了解过模块化的发展的历史吗?分别说说同步和异步模块化的应用场景，说下 AMD 异步模块化实现的原理?如何将项目里面的所有的 require 的模块语法换成 import 的 ES6 的语法?使用模块化加载时，模块加载的顺序是怎样的，如果不知道，根据已有的知识，你觉得顺序应该是怎么样的?九、框架使用过哪些框架?zepto 和 jquery 是什么关系，有什么联系么?jquery 源码如何实现选择器的，为什么$取得的对象要设计成数组的形式，这样设计的目的是什么jquery 如何绑定事件，有几种类型和区别什么是 MVVM，MVC，MVPVue 和 Angular 的双向数据绑定原理Vue，Angular 组件间通信以及路由原理react 和 vue 的生命周期react 和 vue 的虚拟 dom 以及 diff 算法vue 的 observer，watcher，compilereact 和 angular 分别用在什么样的业务吗?性能方面和 MVC 层面上的区别jQuery 对象和 JS 的 Element 有什么区别jQuery 对象是怎么实现的jQuery 除了它封装了一些方法外，还有什么值得我们去学习和使用的?jQuery 的$(‘xxx’)做了什么事情介绍一下 bootstrap 的栅格系统是如何实现的十、数据结构基本数据结构:(数组、队列、链表、堆、二叉树、哈希表等等)8种排序算法，原理，以及适用场景和复杂度说出越多越好的费波拉切数列的实现方法?十一、性能优化cdn 的用法是什么?什么时候用到?浏览器的页面优化?如何优化 DOM 操作的性能单页面应用有什么 SEO 方案?单页面应用首屏显示比较慢，原因是什么?有什么解决方案?]]></content>
  </entry>
  <entry>
    <title><![CDATA[面试知识点大全(2018)]]></title>
    <url>%2F2018%2F04%2F17%2Fmine%2Finterview%2Ffull-knowledge-interview%2F</url>
    <content type="text"><![CDATA[简介一、HtmlHTML5 新特性，语义化浏览器的标准模式和怪异模式xhtml 和 html 的区别使用 data-的好处meta 标签canvasHTML 废弃的标签css js 放置位置和原因什么是渐进式渲染html 模板语言meta viewport 原理二、CSS盒模型，box-sizingCSS3 新特性，伪类，伪元素，锚伪类CSS 实现隐藏页面的方式如何实现水平居中和垂直居中。水平居中垂直居中1234567891011//1.flex.parent-1 &#123; display: flex; flex-direction: row; justify-content: center; align-items: center;&#125;.child-1 &#123; /* */&#125; 12345678910111213//2.margin: auto.parent-2 &#123; position: relative;&#125;.child-2 &#123; position: absolute; top: 0; right: 0; bottom: 0; left: 0; margin: auto;&#125; 12345678910111213// 3.transform.parent-3 &#123; position: relative;&#125;.child-3 &#123; position: absolute; top: 50%; left: 50%; /* -webkit-transform: translateX(-50%,-50%); */ transform: translate(-50%,-50%); /* animation 位置的变化 */&#125; 1234567891011121314//4.宽高的一半.parent-4 &#123; position: relative;&#125;.child-4 &#123; position: absolute; top: 50%; left: 50%; /* 高度的一半 */ margin-top: -20px; /* 宽度的一半 */ margin-left: -40px;&#125; 1234567891011//5.伪类.child-5,.parent-5::after &#123; display: inline-block; vertical-align: middle;&#125;.parent-5::after &#123; content: ''; height: 100%;&#125; 说说 position，display请解释*{box-sizing:border-box;}的作用，并说明使用它的好处浮动元素引起的问题和解决办法?绝对定位和相对定位，元素浮动后的 display 值link 和@import 引入 css 的区别解释一下 css3 的 flexbox，以及适用场景inline 和 inline-block 的区别哪些是块级元素那些是行级元素，各有什么特点grid 布局table 布局的作用实现两栏布局有哪些方法?css dpi你知道 attribute 和 property 的区别么css 布局问题?css 实现三列布局怎么做?如果中间是自适应又怎么做?流式布局如何实现，响应式布局如何实现移动端布局方案实现三栏布局(圣杯布局，双飞翼布局，flex 布局)清除浮动的原理overflow:hidden 有什么缺点?padding 百分比是相对于父级宽度还是自身的宽度css3 动画，transition 和 animation 的区别，animation 的属性，加速度，重力的模拟实现CSS 3 如何实现旋转图片(transform: rotate)sass less对移动端开发了解多少?(响应式设计、Zepto;@media、viewport、 JavaScript 正则表达式判断平台。)什么是 bfc，如何创建 bfc?解决什么问题?CSS 中的长度单位(px,pt,rem,em,ex,vw,vh,vh,vmin,vmax)CSS 选择器的优先级是怎样的?雪碧图svg媒体查询的原理是什么?CSS 的加载是异步的吗?表现在什么地方?常遇到的浏览器兼容性问题有哪些?常用的 hack 的技巧外边距合并解释一下”::before”和”:after”中的双冒号和单冒号的区别层叠样式表（CSS）的主要目的是给HTML元素添加样式，然而，在一些案例中给文档添加额外的元素是多余的或是不可能的。事实上CSS中有一个特性允许我们添加额外元素而不扰乱文档本身，这就是”伪元素”。 CSS 伪类用于向某些选择器添加特殊的效果。(:hover :active) CSS 伪元素用于将特殊的效果添加到某些选择器。 (::after,::before) 伪类和伪元素的根本区别在于：它们是否创造了新的元素(抽象)。从我们模仿其意义的角度来看，如果需要添加新元素加以标识的，就是伪元素，反之，如果只需要在既有元素上添加类别的，就是伪类。 伪元素和伪类之所以这么容易混淆，是因为他们的效果类似而且写法相仿，但实际上 css3 为了区分两者，已经明确规定了伪类用一个冒号来表示，而伪元素则用两个冒号来表示。 12:Pseudo-classes::Pseudo-elements 但因为兼容性的问题，所以现在大部分还是统一的单冒号，但是抛开兼容性的问题，我们在书写时应该尽可能养成好习惯，区分两者。 参考http://www.alloyteam.com/2016/05/summary-of-pseudo-classes-and-pseudo-elements/ 三、JavaScriptjs 的基本类型有哪些?引用类型有哪些?null 和 undefined 的区别。 基本类型有：undefined , null , boolean , srting , number 引用类型有：object , array , function , date , error null是一个表示”无”的对象，转为数值时为0；undefined是一个表示”无”的原始值，转为数值时为NaN。 null表示”没有对象”，即该处不应该有值。undefined表示”缺少值”，就是此处应该有一个值，但是还没有定义。 12345typeof NaN = 'number'typeof null = 'object'//这2个有点难记Number(undefined) = NaN;Number(null) = 0; JavaScript js中的NaN如何产生的？ 怎么区分内存的堆区与栈区。[参考]https://juejin.im/post/5acc7e606fb9a028c67609f7 数据结构中的堆和栈是两种不同的、数据项按序排列的数据结构。 基本类型变量：在内存中分别占有固定大小的空间，他们的值保存在栈空间，通过按值访问、拷贝和比较。(变量的拷贝过程就是拷贝了内存中的一个副本？？？) 引用类型变量：栈内存中存放的只是该对象的访问地址，在堆内存中为该值分配空间，由于这种值的大小不固定，因此不能把他们保存到栈内存中；但内存地址大小是固定的，因此可以将堆内存地址保存到栈内存中。这样，当查询引用类型的变量时，就先从栈中读取堆内存地址，然后再根据该地址取出对应的值。 很显而易见的一点就是，JavaScript 中所有引用类型创建实例时，都是显式或隐式地 new 出对应类型的实例，实际上就是对应 C 语言的 malloc 分配内存函数。 js 中变量的赋值分为「传值」与「传址」。 js有哪些内置对象 内置对象就是指javascript这个语言自带的一些对象 Array数组对象 ， string字符串 ， Math对象 ， Date日期对象 123456789101112//数组对象unshift() //数组开头增加shift() //数组开头删除push() //数组末尾添加pop() //数组末尾删除concat() //数组拼接 //concat可以实现数组的克隆()不传值splice（index, howmany, item1, ...itemx） //数组的删除，增加，替换 ???slice（n,m） //数组截取reverse() //数组翻转sort() //数组排序toString() //数组转字符数join() //数组拼接 12345678910//字符串charAt() //通过索引找字符indexOf() //从前向后找，返回索引lastIndexOf() //从后向前找，返回索引slice() //字符串截取substring() // 这里等价于slice()substr（n，m） // 从索引n开始截取m 个split() //字符串分隔成数组toUpperCase() //转成大写toLowerCase() //转成小写 123456789//MathMath.floor（） //向下取整Math.ceil（） //向上取整Math.random（） //取0-1之间的随机小数Math.round（） //四舍五入Math.abs（） //取绝对值Math.pow（x，y） //x的y次幂Math.sqrt（） //开平方Math.max（） //取最大值 Object 是引用类型嘛?引用类型和基本类型有什么区别?哪个是存在堆哪一个是存在栈上面的?基本类型 基本类型的值是不可变得 基本类型的比较是值的比较 基本类型的变量是存放在栈内存中的 在从一个变量向另一个变量赋值基本类型时，会在该变量上创建一个新值，然后再把该值复制到为新变量分配的位置上： 引用类型 引用类型的值是可变的 引用类型的值是同时保存在栈内存和堆内存中的对象 引用类型的比较是引用的比较 两个变量都保存了同一个对象地址，则这两个变量指向了同一个对象 1234567var person1 = '&#123;&#125;';var person2 = '&#123;&#125;';console.log(person1 == person2); // truevar person2 = &#123;&#125;;var person4 = &#123;&#125;;console.log(person3 == person4); // false 参考https://www.cnblogs.com/focusxxxxy/p/6390536.html 如何判断一个变量是 Array 类型?如何判断一个变量是 Number 类型?typeof 检查基本类型ok，引用类型GG 12345//判断是Array类型let arr = [];arr instanceof Array //truearr.constructor == Array //trueArray.isArray(arr) //true 1234//判断是Number类型let num = 123;typeof num == "number" //truearr.constructor ==Number //true 12// isNaNisNaN(123) = false; JS 常见的 dom 操作 api解释一下事件冒泡和事件捕获事件委托(手写例子)，事件冒泡和捕获，如何阻止冒泡?如何组织默认事 件?对闭包的理解?什么时候构成闭包?闭包的实现方法?闭包的优缺点?this 有哪些使用场景?跟 C,Java 中的 this 有什么区别?如何改变 this 的值?call，apply，bind显示原型和隐式原型，手绘原型链，原型链是什么?为什么要有原型链创建对象的多种方式实现继承的多种方式和优缺点new 一个对象具体做了什么手写 Ajax，XMLHttpRequest变量提升举例说明一个匿名函数的典型用例指出 JS 的宿主对象和原生对象的区别，为什么扩展 JS 内置对象不是好的做法?有哪些内置对象和内置函数?attribute 和 property 的区别document load 和 document DOMContentLoaded 两个事件的区别=== 和 == , [] === [], undefined === undefined,[] == [], undefined== undefinedtypeof 能够得到哪些值什么是”use strict”,好处和坏处函数的作用域是什么?js 的作用域有几种?JS 如何实现重载和多态常用的数组 api，字符串 api原生事件绑定(跨浏览器)，dom0 和 dom2 的区别?给定一个元素获取它相对于视图窗口的坐标如何实现图片滚动懒加载js 的字符串类型有哪些方法? 正则表达式的函数怎么使用?深拷贝编写一个通用的事件监听函数web 端 cookie 的设置和获取setTimeout 和 promise 的执行顺序JavaScript 的事件流模型都有什么?navigator 对象，location 和 historyjs 的垃圾回收机制内存泄漏的原因和场景DOM 事件的绑定的几种方式DOM 事件中 target 和 currentTarget 的区别typeof 和 instanceof 区别，instanceof 原理js 动画和 css3 动画比较JavaScript 倒计时(setTimeout)js 处理异常js 的设计模式知道那些轮播图的实现，以及轮播图组件开发，轮播 10000 张图片过程websocket 的工作原理和机制。手指点击可以触控的屏幕时，是什么事件? 什么是函数柯里化?以及说一下 JS 的 API 有哪些应用到了函数柯里化的实现?(函数柯里化一些了解，以及在 函数式编程的应用，- 最后说了一下 JS 中 bind 函数和数组的 reduce 方法用 到了函数柯里化。)JS 代码调试四、ES6谈一谈 promise所有的 ES6 特性你都知道吗?如果遇到一个东西不知道是 ES6 还是 ES5, 你该怎么区分它es6 的继承和 es5 的继承有什么区别promise 封装 ajaxlet const 的优点es6 generator 是什么，async/await 实现原理ES6 和 node 的 commonjs 模块化规范区别箭头函数，以及它的 this五、计算机网络HTTP 协议头含有哪些重要的部分，HTTP 状态码网络 url 输入到输出怎么做?性能优化为什么要减少 HTTP 访问次数?Http 请求的过程与原理https(对是 https)有几次握手和挥手?https 的原理。http 有几次挥手和握手?TLS 的中文名?TLS 在哪一网络层?TCP 连接的特点，TCP 连接如何保证安全可靠的?为什么 TCP 连接需要三次握手，两次不可以吗，为什么为什么 tcp 要三次握手四次挥手?tcp 的三次握手和四次挥手画图(当场画写 ack 和 seq 的值)?tcp 与 udp 的区别get 和 post 的区别?什么情况下用到?http2 与 http1 的区别?websocket什么是 tcp 流，什么是 http 流babel 是如何将 es6 代码编译成 es5 的http2 的持久连接和管线化域名解析时是 tcp 还是 udp域名发散和域名收敛Post 一个 file 的时候 file 放在哪的?HTTP Response 的 Header 里面都有些啥?六、浏览器相关跨域，为什么 JS 会对跨域做出限制前端安全:xss，csrf…浏览器怎么加载页面的?script 脚本阻塞有什么解决方法?defer 和 async 的 区别?浏览器强缓存和协商缓存浏览器的全局变量有哪些浏览器同一时间能够从一个域名下载多少资源按需加载，不同页面的元素判断标准web 存储、cookies、localstroge 等的使用和区别浏览器的内核如何实现缓存机制?(从 200 缓存，到 cache 到 etag 再到)说一下 200 和 304 的理解和区别什么是预加载、懒加载一个 XMLHttpRequest 实例有多少种状态?dns 解析原理，输入网址后如何查找服务器服务器如何知道你?浏览器渲染过程ie 的某些兼容性问题session拖拽实现拆解 url 的各部分七、工程化对 webpack,gulp，grunt 等有没有了解?对比。webpack 的入口文件怎么配置，多个入口怎么分割。webpack 的 loader 和 plugins 的区别gulp 的具体使用。前端工程化的理解、如何自己实现一个文件打包，比如一个 JS 文件里同时又ES5 和 ES6 写的代码，如何编译兼容他们八、模块化对 AMD,CMD,CommonJS 有没有了解?为什么要模块化?不用的时候和用 RequireJs 的时候代码大概怎么写?说说有哪些模块化的库，有了解过模块化的发展的历史吗?分别说说同步和异步模块化的应用场景，说下 AMD 异步模块化实现的原理?如何将项目里面的所有的 require 的模块语法换成 import 的 ES6 的语法?使用模块化加载时，模块加载的顺序是怎样的，如果不知道，根据已有的知识，你觉得顺序应该是怎么样的?九、框架使用过哪些框架?zepto 和 jquery 是什么关系，有什么联系么?jquery 源码如何实现选择器的，为什么$取得的对象要设计成数组的形式，这样设计的目的是什么jquery 如何绑定事件，有几种类型和区别什么是 MVVM，MVC，MVPVue 和 Angular 的双向数据绑定原理Vue，Angular 组件间通信以及路由原理react 和 vue 的生命周期react 和 vue 的虚拟 dom 以及 diff 算法vue 的 observer，watcher，compilereact 和 angular 分别用在什么样的业务吗?性能方面和 MVC 层面上的区别jQuery 对象和 JS 的 Element 有什么区别jQuery 对象是怎么实现的jQuery 除了它封装了一些方法外，还有什么值得我们去学习和使用的?jQuery 的$(‘xxx’)做了什么事情介绍一下 bootstrap 的栅格系统是如何实现的十、数据结构基本数据结构:(数组、队列、链表、堆、二叉树、哈希表等等)8种排序算法，原理，以及适用场景和复杂度说出越多越好的费波拉切数列的实现方法?十一、性能优化cdn 的用法是什么?什么时候用到?浏览器的页面优化?如何优化 DOM 操作的性能单页面应用有什么 SEO 方案?单页面应用首屏显示比较慢，原因是什么?有什么解决方案?]]></content>
      <categories>
        <category>我的</category>
      </categories>
      <tags>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[react中遇到的一些问题的解答]]></title>
    <url>%2F2018%2F04%2F11%2Freact%2Fquestions%2F</url>
    <content type="text"><![CDATA[简介Question1 为什么请求数据要在钩子函数(componentDidMount)里面调用?这与React组件的生命周期有关，组件挂载时有关的生命周期有以下几个: constructor() componentWillMount() render() componentDidMount() 上面这些方法的调用是有次序的，由上而下，也就是当说如果你要获取外部数据并加载到组件上，只能在组件”已经”挂载到真实的网页上才能作这事情，其它情况你是加载不到组件的。 componentDidMount方法中的代码，是在组件已经完全挂载到网页上才会调用被执行，所以可以保证数据的加载。此外，在这方法中调用setState方法，会触发重渲染。所以，官方设计这个方法就是用来加载外部数据用的，或处理其他的副作用代码。 constructor被调用是在组件准备要挂载的最一开始，所以此时组件尚未挂载到网页上。 componentWillMount方法的调用在constructor之后，在render之前，在这方法里的代码调用setState方法不会触发重渲染，所以它一般不会用来作加载数据之用，它也很少被使用到。 一般的从后台(服务器)获取的数据，都会与组件上要用的数据加载有关，所以都在componentDidMount方法里面作。虽然与组件上的数据无关的加载，也可以在constructor里作，但constructor是作组件state初绐化工作，并不是设计来作加载数据这工作的，所以所有有副作用的代码都会集中在componentDidMount方法里。 Question2 在componentWillMount()钩子函数里面 setState 为啥不会再次触发render（）？setState会有一个批量处理的操作 Question3 子组件和父组件componentDidMount哪一个先执行 子组件先执行 父组件的componentDidMount方法会在其render的全部内容装载到DOM后执行，若父组件中包含定义的子组件，则componentDidMount方法会在子组件执行完实例化周期后再执行 所有平行子组件首次render后，再依次执行componentDidMount]]></content>
      <categories>
        <category>react</category>
      </categories>
      <tags>
        <tag>react技术栈</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[TSX回调中必须注意的 this 指向]]></title>
    <url>%2F2018%2F04%2F10%2Freact%2Fjsx-class-this%2F</url>
    <content type="text"><![CDATA[简介class关键字基本上，ES6 的class可以看作只是一个语法糖，它的绝大部分功能，ES5 都可以做到，新的class写法只是让对象原型的写法更加清晰、更像面向对象编程的语法而已。上面的代码用 ES6 的class改写，就是下面这样。 123456789101112131415161718192021222324class Toggle extends React.Component &#123; constructor(props) &#123; super(props); this.state = &#123;isToggleOn: true&#125;; // 这个绑定是必要的，使`this`在回调中起作用 this.handleClick = this.handleClick.bind(this); &#125; handleClick() &#123; this.setState(prevState =&gt; (&#123; isToggleOn: !prevState.isToggleOn &#125;)); &#125; render() &#123; return ( &lt;button onClick=&#123;this.handleClick&#125;&gt; &#123;this.state.isToggleOn ? 'ON' : 'OFF'&#125; &lt;/button&gt; ); &#125;&#125;]]></content>
      <categories>
        <category>react</category>
      </categories>
      <tags>
        <tag>react技术栈</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Airbnb React/JSX 编码规范]]></title>
    <url>%2F2018%2F04%2F10%2Freact%2Freact-jsx-style-guide%2F</url>
    <content type="text"><![CDATA[简介 参考 Airbnb React/JSX Style Guide 算是最合理的React/JSX编码规范之一了。 Create创建模块如果你的模块有内部状态或者是refs, 推荐使用 class extends React.Component 而不是 React.createClass。 123456789101112131415// badconst Listing = React.createClass(&#123; // ... render() &#123; return &lt;div&gt;&#123;this.state.hello&#125;&lt;/div&gt;; &#125;&#125;);// goodclass Listing extends React.Component &#123; // ... render() &#123; return &lt;div&gt;&#123;this.state.hello&#125;&lt;/div&gt;; &#125;&#125; 如果你的模块没有状态或是没有引用refs， 推荐使用普通函数（非箭头函数）而不是类: 12345678910111213141516// badclass Listing extends React.Component &#123; render() &#123; return &lt;div&gt;&#123;this.props.hello&#125;&lt;/div&gt;; &#125;&#125;// bad (relying on function name inference is discouraged)const Listing = (&#123; hello &#125;) =&gt; ( &lt;div&gt;&#123;hello&#125;&lt;/div&gt;);// goodfunction Listing(&#123; hello &#125;) &#123; return &lt;div&gt;&#123;hello&#125;&lt;/div&gt;;&#125; Naming 命名 文件名: 文件名使用帕斯卡命名. 如, ReservationCard.jsx. 引用命名: React模块名使用帕斯卡命名，实例使用骆驼式命名. 1234567891011// badimport reservationCard from './ReservationCard';// goodimport ReservationCard from './ReservationCard';// badconst ReservationItem = &lt;ReservationCard /&gt;;// goodconst reservationItem = &lt;ReservationCard /&gt;; 模块命名: 模块使用当前文件名一样的名称. 比如 ReservationCard.jsx 应该包含名为 ReservationCard的模块. 但是，如果整个文件夹是一个模块，使用 index.js作为入口文件，然后直接使用 index.js 或者文件夹名作为模块的名称: 12345678// badimport Footer from './Footer/Footer';// badimport Footer from './Footer/index';// goodimport Footer from './Footer'; 属性命名: 避免使用DOM相关的属性来用作其他的用途。 12345// bad&lt;MyComponent style="fancy" /&gt;// good&lt;MyComponent variant="fancy" /&gt; Alignment 代码对齐1234567891011121314151617181920// bad&lt;Foo superLongParam="bar" anotherSuperLongParam="baz" /&gt;// good, 有多行属性的话, 新建一行关闭标签&lt;Foo superLongParam="bar" anotherSuperLongParam="baz"/&gt;// 若能在一行中显示, 直接写成一行&lt;Foo bar="bar" /&gt;// 子元素按照常规方式缩进&lt;Foo superLongParam="bar" anotherSuperLongParam="baz"&gt; &lt;Quux /&gt;&lt;/Foo&gt; Quotes 单引号还是双引号 对于JSX属性值总是使用双引号(“), 其他均使用单引号(‘). 为什么? HTML属性也是用双引号, 因此JSX的属性也遵循此约定. 1234567891011// bad&lt;Foo bar='bar' /&gt;// good&lt;Foo bar="bar" /&gt;// bad&lt;Foo style=&#123;&#123; left: "20px" &#125;&#125; /&gt;// good&lt;Foo style=&#123;&#123; left: '20px' &#125;&#125; /&gt; Props 属性 JSX属性名使用骆驼式风格camelCase. 123456789// bad&lt;foo username="hello" phone_number="&#123;12345678&#125;"&gt;&lt;/foo&gt;// good&lt;foo username="hello" phonenumber="&#123;12345678&#125;"&gt;&lt;/foo&gt; 如果属性值为 true, 可以直接省略. 12345678910111213// bad&lt;Foo hidden=&#123;true&#125;/&gt;// good&lt;Foo hidden/&gt;// good&lt;Foo hidden /&gt; 避免使用数组的index来作为属性key的值，推荐使用唯一ID. 12345678910111213141516// bad&#123;todos.map((todo, index) =&gt; &lt;Todo &#123;...todo&#125; key=&#123;index&#125; /&gt;)&#125;// good&#123;todos.map(todo =&gt; ( &lt;Todo &#123;...todo&#125; key=&#123;todo.id&#125; /&gt;))&#125; 对于所有非必须的属性，总是手动去定义defaultProps属性. 1234567891011121314151617181920212223// badfunction SFC(&#123; foo, bar, children &#125;) &#123; return &lt;div&gt;&#123;foo&#125;&#123;bar&#125;&#123;children&#125;&lt;/div&gt;;&#125;SFC.propTypes = &#123; foo: PropTypes.number.isRequired, bar: PropTypes.string, children: PropTypes.node,&#125;;// goodfunction SFC(&#123; foo, bar, children &#125;) &#123; return &lt;div&gt;&#123;foo&#125;&#123;bar&#125;&#123;children&#125;&lt;/div&gt;;&#125;SFC.propTypes = &#123; foo: PropTypes.number.isRequired, bar: PropTypes.string, children: PropTypes.node,&#125;;SFC.defaultProps = &#123; bar: '', children: null,&#125;; 特别提醒：尽可能地筛选出不必要的属性。 1234567891011//goodrender() &#123; const &#123; irrelevantProp, ...relevantProps &#125; = this.props; return &lt;WrappedComponent &#123;...relevantProps&#125; /&gt;&#125;//badrender() &#123; const &#123; irrelevantProp, ...relevantProps &#125; = this.props; return &lt;WrappedComponent &#123;...this.props&#125; /&gt;&#125; Refs 总是在Refs里使用回调函数 123456789// bad&lt;Foo ref="myRef"/&gt;// good ???&lt;Foo ref=&#123;(ref) =&gt; &#123; this.myRef = ref; &#125;&#125;/&gt; Parentheses 括号 将多行的JSX标签写在 ()里 123456789101112131415161718192021// badrender() &#123; return &lt;MyComponent className="long body" foo="bar"&gt; &lt;MyChild /&gt; &lt;/MyComponent&gt;;&#125;// goodrender() &#123; return ( &lt;MyComponent className="long body" foo="bar"&gt; &lt;MyChild /&gt; &lt;/MyComponent&gt; );&#125;// good, 单行可以不需要render() &#123; const body = &lt;div&gt;hello&lt;/div&gt;; return &lt;MyComponent&gt;&#123;body&#125;&lt;/MyComponent&gt;;&#125; Methods 函数 当在 render() 里使用事件处理方法时，提前在构造函数里把 this 绑定上去 为什么? 在每次 render 过程中， 再调用 bind 都会新建一个新的函数，浪费资源. 123456789101112131415161718192021222324252627// badclass extends React.Component &#123; onClickDiv() &#123; // do stuff &#125; render() &#123; return &lt;div onClick=&#123;this.onClickDiv.bind(this)&#125; /&gt;; &#125;&#125;// goodclass extends React.Component &#123; constructor(props) &#123; super(props); this.onClickDiv = this.onClickDiv.bind(this); &#125; onClickDiv() &#123; // do stuff &#125; render() &#123; return &lt;div onClick=&#123;this.onClickDiv&#125; /&gt;; &#125;&#125; 在 render 方法中总是确保 return 返回值 123456789// badrender() &#123; (&lt;div /&gt;);&#125;// goodrender() &#123; return (&lt;div /&gt;);&#125; Object 定义对象的细节逗号问题 单行定义的对象结尾不要逗号： 12345// badconst a = &#123; k1: v1, k2: v2, &#125;;// goodconst a = &#123; k1: v1, k2: v2 &#125;; 多行定义的对象要保留逗号： 1234567891011// badconst b = &#123; k1: v1, k2: v2&#125;;// goodconst b = &#123; k1: v1, k2: v2,&#125;; 一次性初始化完全 不要声明之后又给对象添加新属性： 1234567// badconst a = &#123;&#125;;a.x = 3;// goodconst a = &#123; x: null &#125;;a.x = 3; 如果一定非要加请使用Object.assign： 12const a = &#123;&#125;;Object.assign(a, &#123; x: 3 &#125;);]]></content>
      <categories>
        <category>前端规范</category>
      </categories>
      <tags>
        <tag>前端规范</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[react技术栈整理]]></title>
    <url>%2F2018%2F04%2F09%2Freact%2Freact-stack-url%2F</url>
    <content type="text"><![CDATA[简介使用react开发需要掌握一套完整的react技术栈，下面简单归纳下，后续会不断更新！ 单列技术点总结篇 一个 react + redux 的完整项目 和 个人总结（react的生命周期） https://github.com/bailicangdu/react-pxq 现代 Web 开发–React 篇 https://github.com/wxyyxc1992/Web-Series/tree/master/React React.js 初学者应该知道的9件事 http://www.iteye.com/news/31748]]></content>
      <categories>
        <category>react</category>
      </categories>
      <tags>
        <tag>react技术栈</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[文档写作注意点]]></title>
    <url>%2F2018%2F04%2F09%2FREADME%2F</url>
    <content type="text"><![CDATA[简介关于阅读量 文档名不要乱更改，更改会重置文档阅读量 文件夹命名和路径的更改也会重置文档阅读量 date的更改会重置文档阅读量，update不会,title不会]]></content>
      <categories>
        <category>README</category>
      </categories>
      <tags>
        <tag>README</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[react的diff算法]]></title>
    <url>%2F2018%2F04%2F09%2Freact%2Fdiff%2F</url>
    <content type="text"><![CDATA[简介参考 https://segmentfault.com/a/1190000000606216]]></content>
      <categories>
        <category>react</category>
      </categories>
      <tags>
        <tag>react技术栈</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[操作数组的一些方法]]></title>
    <url>%2F2018%2F04%2F08%2Fjavascript%2Fhandle-array%2F</url>
    <content type="text"><![CDATA[简介在实际的项目开发过程中，基于对象或者数组而开发是特别常见的，所以整理了下能操作数组的一些js方法。（包括ES6的） reduce()定义Array.prototype.reduce() 方法接收一个函数作为累加器，数组中的每个值（从左到右）开始缩减，最终计算为一个值。reduce() 可以作为一个高阶函数，用于函数的 compose。 语法 array.reduce(function(total, currentValue, currentIndex, arr), initialValue) 12345total: 必需。初始值, 或者计算结束后的返回值。currentValue: 必需。当前元素currentIndex: 可选。当前元素的索引arr: 可选。当前元素所属的数组对象。initialValue: 可选。传递给函数的初始值 实例计算所有count值的总和12345//数组求和var sum = [0, 1, 2, 3].reduce((total, item)=&gt; &#123; return total + item;&#125;, 0);// sum is 6 12345678910111213//二维数组变成一维数组var flattened = [[0, 1], [2, 3], [4, 5]].reduce((total, item) =&gt; &#123; return total.concat(item);&#125;, []);//orvar flattened = [[0, 1], [2, 3], [4, 5]].reduce((total, item) =&gt; &#123; return [...total, ...item];&#125;, []);// flattened is [0, 1, 2, 3, 4, 5] 1234567891011121314//计算数组中每个元素出现的次数var names = ['Alice', 'Bob', 'Tiff', 'Bruce', 'Alice'];var countedNames = names.reduce(function (allNames, name) &#123; if (name in allNames) &#123; allNames[name]++; &#125; else &#123; allNames[name] = 1; &#125; return allNames;&#125;, &#123;&#125;);// countedNames is:// &#123; 'Alice': 2, 'Bob': 1, 'Tiff': 1, 'Bruce': 1 &#125; Object.keys()定义Object.keys() 方法会返回一个由一个给定对象的自身可枚举属性组成的数组，数组中属性名的排列顺序和使用 for…in 循环遍历该对象时返回的顺序一致 （两者的主要区别是 一个 for-in 循环还会枚举其原型链上的属性）。 语法 Object.keys(obj) 1234567891011// simple arrayvar arr = ['a', 'b', 'c'];console.log(Object.keys(arr)); // console: ['0', '1', '2']// array like objectvar obj = &#123; 0: 'a', 1: 'b', 2: 'c' &#125;;console.log(Object.keys(obj)); // console: ['0', '1', '2']// array like object with random key orderingvar anObj = &#123; 100: 'a', 2: 'b', 7: 'c' &#125;;console.log(Object.keys(anObj)); // console: ['2', '7', '100'] 实例ES6 (for in) (for of) (forEach)for in for…in语句以任意顺序遍历一个对象的可枚举属性。对于每个不同的属性，语句都会被执行。 语法 for (variable in object) {…} 提示：for…in不应该用于迭代一个 Array，其中索引顺序很重要。 实例12345678910var obj = &#123;a:1, b:2, c:3&#125;;for (var prop in obj) &#123; console.log("obj." + prop + " = " + obj[prop]);&#125;// Output:// "obj.a = 1"// "obj.b = 2"// "obj.c = 3" 123for (let index in arr) &#123; console.log("for in:" + arr[index]);&#125; 1.index索引为字符串型数字，不能直接进行几何运算(for in遍历的是数组的索引（即键名），而for of遍历的是数组元素值。) 2.遍历顺序有可能不是按照实际数组的内部顺序 3.使用for in会遍历数组所有的可枚举属性，包括原型。例如上栗的原型方法method和name属性.所以for in更适合遍历对象，不要使用for in遍历数组。 for of for…of语句在可迭代对象（包括 Array，Map，Set，String，TypedArray，arguments 对象等等）上创建一个迭代循环，调用自定义迭代钩子，并为每个不同属性的值执行语句。 12345678910//迭代 arraylet iterable = [10, 20, 30];for (let value of iterable) &#123; value += 1; console.log(value);&#125;// 11// 21// 31 123456789//迭代 stringlet iterable = "boo";for (let value of iterable) &#123; console.log(value);&#125;// "b"// "o"// "o" forEach Array.prototype.forEach()性能方面都很好，只能遍历数组，不可遍历字符串等！不能使用break，return等 12345678const arr = ['a', 'b', 'c'];arr.forEach(function (element, index, array) &#123; // element: 指向当前元素的值 // index: 指向当前索引 // array: 指向Array对象本身 console.log(element + ',' + index + ',' + typeof (array));&#125;); Map/Set Set 对象允许你存储任何类型的唯一值，无论是原始值或者是对象引用。 Set对象是值的集合，你可以按照插入的顺序迭代它的元素。 Set中的元素只会出现一次，即 Set 中的元素是唯一的。 123//所以可以用Set做数组去重[...new Set([1,1,2,2,3,3])] // [1,2,3] Array.from(new Set([1,1,2,2,3,3])) // [1,2,3] find()/findIndex() find() 方法返回数组中满足提供的测试函数的第一个元素的值。否则返回 undefined。 123456let arr = [1, 2, 3, 4];//find方法的回调函数可以接受4个参数，依次为当前的值、当前的位置和原数组,thisValuelet find = arr.find((item, index, arrs) =&gt; &#123; return item === 3;&#125;);找不到返回undefined findIndex()方法返回数组中满足提供的测试函数的第一个元素的索引。否则返回-1。 12345//findIndex方法的回调函数可以接受4个参数，依次为当前的值、当前的位置和原数组,thisValuelet arr = [1, 2, 3, 4];let findIndex = arr.findIndex((item, index, arrs) =&gt; &#123; return item === 3;&#125;) map()Array.prototype.map() 方法创建一个新数组，其结果是该数组中的每个元素都调用一个提供的函数后返回的结果。 语法 array.map(function(currentValue,index,arr), thisValue) 12345currentValue: 必须。当前元素的值currentValue: 可选。当期元素的索引值currentValue: 可选。当期元素属于的数组对象currentValue: 可选。对象作为该执行回调时使用，传递给函数，用作 "this" 的值。如果省略了 thisValue ，"this" 的值为 "undefined" 实例jsx语法中，遍历循环的话使用map的情况特别多。 12345//普通用法let arr = [1, 2, 3, 4, 5];let mapArr = arr.map((item, index) =&gt; &#123; return item * item;&#125;); 123//数组的数字转化为字符串[1, 2, 3, 4, 5, 6, 7, 8, 9].map(String);//["1", "2", "3", "4", "5", "6", "7", "8", "9"] 数组拼接的一些方法concat()定义concat() 方法用于连接两个或多个数组。该方法不会改变现有的数组，而仅仅会返回被连接数组的一个副本。 语法 arrayObject.concat(arrayX,arrayX,……,arrayX) 1arrayX: 必需。该参数可以是具体的值，也可以是数组对象。可以是任意多个。 实例12const a = [1,2,3];let b = a.concat(4,5); //[1,2,3,4,5] join()定义 join() 方法用于把数组中的所有元素转换一个字符串。 语法1array.join(separator)//指定要使用的分隔符 […] es6 扩展运算符 123const arr1 = [1,2,3];const arr2 = [4,5];const arr3 = [...arr1, ...arr2]; 数组截取的一些方法splice() splice() 方法通过删除现有元素和/或添加新元素来更改一个数组的内容。 语法12345array.splice(start)array.splice(start, deleteCount)array.splice(start, deleteCount, item1, item2, ...) start: 指定修改的开始位置（从0计数）。如果超出了数组的长度，则从数组末尾开始添加内容. deleteCount?: 整数，表示要移除的数组元素的个数。如果 deleteCount 是 0，则不移除元素。 item1, item2, … 要添加进数组的元素,从start 位置开始。 12345var myFish = ["angel", "clown", "mandarin", "surgeon"];//从第 2 位开始删除 0 个元素，插入 "drum"var removed = myFish.splice(2, 0, "drum");//运算后的 myFish:["angel", "clown", "drum", "mandarin", "surgeon"]//被删除元素数组：[]，没有元素被删除 fill() 方法定义Array.prototype.fill()方法用一个固定值填充一个数组中从起始索引到终止索引内的全部元素。 语法 array.fill(value, start, end) 123value: 必需。填充的值。start: 可选。开始填充位置。(下标从1开始)end: 可选。停止填充位置 (默认为 array.length) 实例12var fruits = ["Banana", "Orange", "Apple", "Mango"];fruits.fill("Runoob", 2, 4); //Banana,Orange,Runoob,Runoob 12new Array(5).fill(0); //[0, 0, 0, 0, 0]new Array(5).fill(false); // [false, false, false, false, false]]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>Array</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[简历01]]></title>
    <url>%2F2018%2F04%2F08%2Fmine%2Finterview%2Fresume0408%2F</url>
    <content type="text"><![CDATA[简介 我的前端面试简历 教育背景主修课程: phyon，C 语言，C++数据结构与算法，Java 基础，编译原理，计算机组成原理, 操作系统原理，计算机网络原 理，html 和 css 基础，JavaScript，php，SQL，大学英语，高数 个人技能 熟悉前端基础知识 html5，css3 等，熟悉 JavaScript，jQuery; 熟悉页面架构和布局(栅格布局，响应式布局，弹性布局)，熟悉 css 的扩展语言 Sass，Less 的基本用法; 熟悉 W3C 标准，理解各主流浏览器间的兼容性问题，有强烈的前端性能优化意识; 了解 JavaScript 语言的标准 ES5，ES6。熟悉面向对象编程，学习过 typescript 等强类型语言; 熟悉一些前端工程化打包工具，如 gulp，webpack; 了解 cordova 基本插件以及打包方式; 7.熟悉一些口语测评插件，如科大讯飞，云知声等插件的录音、上传、测评等 API; 熟悉前端 UI 框架 onsenui，angular material，ant design; 熟悉 svn，git，gitlab 等开发工具，开发过程中使用过 Tower，sourceTree 等工具，平时会在 GitHub 上整理一些小东西; 熟悉 angularjs 框架，能够搭建一个 angularjs+webpack+onsen+ES6+cordova 的前端工程; 熟悉 react 框架，能够搭建一个 react+webpack+antd+redux 的前端工程; 具备良好的学习能力、沟通能力、分析能力、bug 快速定位能力及解决问题能力; 对前端工程规范，代码标准规范，开发性能等期望很大，并在不断学习和提升; 工作态度很好，积极乐观，责任心强，喜欢不断学习和提升。 工作经验2015-10-23 至 2015-12-24—–上海汉得信息技术股份有限公司——培训生(实习) 知识点:java spring，SQL，PLSQL，oracle 公司去学校几轮面试后来到公司还是以培训为主，在此期间主要了解过javaspring，SQL，PLSQL，oracle 数据库和公司内部框架(oraler),然后参与公司内部框架的维护和搭建 知识点:css，JavaScript，JQ 这是我参与的第一个前端项目，主要任务是公司招聘网站开发，然后做一些页面，动画，和小逻辑，后期以 bug 修复为主。主要用到技术是 javaweb，JQ 等。 2016-03-07 至 2017-04-07—–上海汉得信息技术股份有限公司——前端开发工程师 知识点:angularjs+cordova+onsenui+gulp+es6 该工程主要是用前端流行框架 angularjs 搭建的学生端 APP 以及 PC 端答题模板页面从 js 到 angularjs 的改版， 使用 webpack，gulp 打包工具搭建 cordova 的 android 以及 ios 平台打包，最 终发布到各大 android 软件下载 网站以及 ios 的 appstore 供用户下载使用，该项目使用了 svn 后面使 用 gitlab 来管理工程代码的开发。 我主要负责多种题型下用户预览，答题，提交等各种交互的逻辑处理， 以及答题模板页面从 app 到 pc 的响应式布局的开发与搭建;解决 android 各种机型，ios 各版本以及 pc 浏览器兼容性 bug;以及后面功能点的不断迭代开发。改项目过程中，对打包插件 cordova 有一定的了 解，如手机的各种访问权限设置，头像上传等。 2016-06-07 至 2016-09-01—–上海汉得信息技术股份有限公司——前端开发工程师 知识点:前端工程规范和优化 改项目主要是针对前面开发过的 angularjs 项目做的一个前端优化项目，引入了强类型语言 typescript，提 高代码的严谨性;总结了一套前端工程和代码规范并实施;同时也对内存问题做了一些优化，利用 google 的调试工具 Memory 捕获内存快照和分析，一定程度的解决了内存泄漏问题。 2017-04-07 至 今—–上海汉得信息技术股份有限公司——前端开发工程师 知识点:react+webpack+redux+antd+saga+es6 该工程主要是用前端流行框架 reactjs 搭建的教师端 APP 以及 PC 端的项目。使用 react 框架以及 react-reduax，react-saga，react-router 等一系列中间件实现教师端 app 以及 pc 端的功能开发，其中 使用了 webpack 代码管理工具以及包管理工具 npm，用 cordova 搭建 ios 和 android 平台打包发布， 期间学会了使用 jenkinsfile 自动打包发布程序代码，该项目使用了 git 来管理工程代码的开发。 我主要负责的是 app 和 pc 教师布置作业的一条流程，题型组件开发好之后，我把他们整合起来实现教师布 置，预览，加题，换题，删题，布置和发布的一系列流程;同时也负责一种题型组件的开发;在此期间，担 任一次迭代项目的组长，并积极吧项目推上线。 2017-11-15 至 2018-01-15—–上海汉得信息技术股份有限公司——前端开发工程师 知识点: createjs，JavaScript，JQuery，gulp，H5 学习包项目:这个项目历时2个月，是我主导的一个游戏开发项目，主要是用createjs实现多个游戏的开发， 并且还有很多超炫的动画和 UI。主要技术:createjs，JQuery，gulp，H5。项目前期主要和产品沟通确认 所有需求，然后根据需求在技术方面和总监考虑项目使用技术。确定下来后，就开始将难点一一罗列，分工 研究和实现，做出项目任务量和难点的排期汇报给领导，然后将任务分配到人和天，通过过进度和开会的方 法共同解决一些棘手问题，直到项目上线。 获得证书 英语 4，6 级证书;国家计算机 2 级证书;国家励志奖学金(2 次) 个人评价 本人从实习开始到现在，从事前端开发2年多了。虽然最最开始的时候自己是弱鸡，但是上进心大，责任心强，关键肯吃苦，很多项目都是按时或者提前完成。并且有时候主动要求一些重难点的任务。工作期间喜欢问，喜欢和同事和领导讨论技术问题，平时也喜欢去GitHub粉一些大佬，追求一些优雅的编程风格，很多东西都喜欢问为什么，喜欢问XX标准XX规范是怎么来的。所以喜欢在编程世界里面探索！]]></content>
      <categories>
        <category>我的</category>
      </categories>
      <tags>
        <tag>简历</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[致年轻的自己]]></title>
    <url>%2F2018%2F04%2F08%2Fmine%2Fpower%2Fyoung-self%2F</url>
    <content type="text"><![CDATA[致年轻的自己20-30岁你拿这十年做什么？ [尴尬]篇20多岁的尴尬，是迷茫，是害怕；是才华配不上梦想；是付出配不上野心；是现实与生活的较量。 [苦才是人生]篇矛盾说，我从来不梦想，我只是在努力认识现实；洪深说，我的梦想是明年吃苦比今年更强；鲁迅说，人生最大的痛苦是梦醒了无路可走！]]></content>
      <categories>
        <category>我的</category>
      </categories>
      <tags>
        <tag>谁的清楚不迷茫</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[做了一年的react自己的感悟和总结]]></title>
    <url>%2F2018%2F04%2F04%2Freact%2Freact-think%2F</url>
    <content type="text"><![CDATA[简介react确实是一个神奇而优雅的框架。在从事react项目之前，一直是在做angular的，angular是一个全面和庞大的框架，在起初设计的时候什么都有，复杂程度也很高，所以用angular做项目基本上不需要其他的辅助库来配合。但是react项目真的是不一样了，要是只会一个react的话，很难开发出需求的。因为react就只负责UI的渲染。 做react项目需要掌握什么react 功能单一用于UI渲染，redux 用来管理数据，react-router 用来管理路由，webpack 用来配置工程，ES6 让代码更加优雅，redux-saga 用来处理异步请求，reselect 缓存机制用来减少state改变带来的渲染压力,还有一些为了交互衍生出来的中间件 react-redux、react-router-redux、react-router-dom ，预处理器Sass或Less 尽量也掌握下。 react 前面有说过react只负责ui的渲染 从V-dom出发react最难能可贵的就是虚拟dom的思想，这里有个贴切的比喻：把dom和JavaScript想象为各自的2个岛屿，中间有桥梁相连，但是桥上设有收费站，JavaScript去访问dom岛屿的次数越多，费用就越高。这就是一个js操作dom的过程，也许我们经常听到或者看到说尽量少的去操作dom，很耗性能。但是DOM 操作成本到底高在哪儿？,这边小总结下： 从输入uri到页面加载好是一个很漫长的过程，我们就从html的解析开始说起。①解析HTML，开始构建DOM树；②解析CSS，生成CSS规则树；③合并DOM树和CSS规则树，生成render树；④布局render树（Layout/reflow），这时候负责元素尺寸大小，位置的计算，属于js中回流过程；⑤绘制render树（paint），绘制页面像素，属于重绘的过程；⑥浏览器会将各层的信息发送给GPU(图像处理器)，GPU将各层合成（composite），显示在屏幕上。这是初始化渲染的过程，通过js操作DOM后，会引起 回流 和重绘，回流的成本很高，一个节点的回流会导致兄弟节点和子节点的回流，这样就一直在消耗GPU资源，所以才有了成本高的说法。 我们从操作dom的成本开始引入react，它创造了虚拟dom并且将它们储存起来，每当状态发生变化的时候就会创造新的虚拟节点和以前的进行对比，让变化的部分进行渲染。整个过程没有对dom进行获取和操作，只有等真正render时，才会去操作真实dom，从而引发页面的渲染。 diff算法react的diff算法用在什么地方呢？当组件更新的时候，react会创建一个新的虚拟dom树并且会和之前储存的dom树进行比较，这个比较的过程就用到了diff算法，所以组件初始化的时候是用不到的。react提出了一种假设，相同的节点具有类似的结构，而不同的节点具有不同的结构。在这种假设之上进行逐层的比较，如果发现对应的节点是不同的，那就直接删除旧的节点以及它所包含的所有子节点然后替换成新的节点。如果是相同的节点，则只进行属性的更改。 对于列表的diff算法稍有不同，因为列表通常具有相同的结构，在对列表节点进行删除，插入，排序的时候，单个节点的整体操作远比一个个对比一个个替换要好得多，所以在创建列表的时候需要设置key值，这样react才能分清谁是谁。当然不写key值也可以，但这样通常会报出警告，通知我们加上key值以提高react的性能。 需要了解清楚，看源码 单项数据流 组件化组件就是拥有独立功能的视图模块,React的最大好处在于：功能组件化，遵守前端可维护的原则。 组件生命周期 组件初始化会触发的5个钩子函数1.getDefaultProps() 设置默认的props，也可以用defaultProps设置组件的默认属性。 getDefaultProps相当于ES6中的 static defaultProps = {} 2.getInitialState() 在使用es6的class语法时是没有这个钩子函数的，可以直接在constructor中定义this.state。此时可以访问this.props。 getInitialState相当于ES6 class中constructor的 this.state = {} 钩子函数1 2 只有用React.createClass方法创造的组件类才会发生作用，并且React.createClass已经被Fb官方废弃，所以这里不细讲了。 3.componentWillMount() 组件初始化时只调用，以后组件更新不调用，整个生命周期只调用一次，此时可以修改state。 4.render() react最重要的步骤，创建虚拟dom，进行diff算法，更新dom树都在此进行。 render() 应该是一个纯函数，完全根据state和props来决定返回结果，而不产生副作用，所以render中调用setState是错的，因为纯函数不应该引起状态的改变 5.componentDidMount() 组件渲染之后调用，可以通过this.getDOMNode()获取和操作dom节点，只调用一次。 did的前缀表示进入状态之后调用，比如componentDidMount，组件一般初始化都会在这里进行数据请求。 为什么请求数据要在这个钩子函数里面调用? 我的总结详见react中遇到的一些问题的解答 组件交互更新时触发的5个钩子函数6.componentWillReceiveProps(nextProps) 组件初始化时不调用，组件接受新的props时调用。 开发过程中一般是在这个钩子函数里面改变state,此方法中改变state不会二次渲染而是进行state合并。 7.shouldComponentUpdate(nextProps, nextState) react性能优化非常重要的一环。组件接受新的state或者props时调用，我们可以设置在此对比前后两个props和state是否相同，如果相同则返回false阻止更新，因为相同的属性状态一定会生成相同的dom树，这样就不需要创造新的dom树和旧的dom树进行diff算法对比，节省大量性能，尤其是在dom结构复杂的时候。不过调用this.forceUpdate会跳过此步骤。 8.componentWillUpdate(nextProps, nextState) 组件初始化时不调用，只有在组件将要更新时才调用。 千万不要在这个函数中调用this.setState()方法，会造成循环调用。 9.render() 同上render()，创建虚拟dom，进行diff算法，更新dom树都在此进行。 10.componentDidUpdate() 组件初始化时不调用，组件更新完成后调用，此时可以获取dom节点。 在componentDidUpdate后才能获取更新后的this.state。如果想获取组件默认的props，并且赋值给State ,就可以在这里修改，达到UI上的效果。 组件卸载时调用10.componentWillUnmount() 组件将要卸载时调用，一些事件监听和定时器需要在此时清除,还有此组件store上面的值也可以对应的清楚。 componentWillUnmount执行重置所有相关参数。在该方法中调用setState不会触发render，因为所有的更新队列，更新状态都被重置为null。 123456789//数据清楚需要写在reducer里面this.props.clearPointData();[CLEAR_POINT_DATA]: (state, action: Action&lt;any&gt;) =&gt; &#123; return Object.assign(&#123;&#125;, state, &#123; selectedReadingList: &#123;&#125;, knowledgePoint: &#123;&#125;, &#125;);&#125; 以上可以看出来react总共有10个周期函数（render重复一次），这个10个函数可以满足我们所有对组件操作的需求，利用的好可以提高开发效率和组件性能。 reduxreact-reduxreact-router要了解下router的机制 react-router-redux保持路由与应用状态（state）同步。使用redux管理应用状态(state)，使用router管理路由，两个库不能协同工作，react-router-redux库可以协调这两个库。 react-router-domredux-sagareselectES6webpack参考webpack官网 Sass or Less随着前端的不断发展，网站的页面复杂度也在不断提升，原生 CSS 已经让开发者力不从心，预处理器赋予我们的 “超能力”。浅谈 CSS 预处理器：为什么要使用预处理器？ Sass参考Sass语法 Less参考Less语法]]></content>
      <categories>
        <category>react</category>
      </categories>
      <tags>
        <tag>react技术栈</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[平时整理的css水平垂直居中]]></title>
    <url>%2F2018%2F03%2F28%2Flayout%2Fcss-center%2F</url>
    <content type="text"><![CDATA[水平垂直居中Learn more here掘金-CSS的垂直居中和水平居中总结 16种方法实现水平居中垂直居中 水平居中1.行内元素（inline element）, 给其父元素设置 text-align:center （适用行内元素）什么是行内元素，块级元素 12inline element也叫内联元素、内嵌元素等；行内元素一般都是基于语义级(semantic)的基本元素，只能容纳文本或其他内联元素，常见内联元素 “a”。比如 SPAN 元素，IFRAME元素和元素样式的display : inline的都是行内元素。 2.块级元素（block element）, 该元素设置 margin:0 auto即可.只有块级元素才生效（让整个块元素居中）margin 0 auto与text-align:center的区别 1text-align:center设置为文本或img标签等一些内联对象（或与之类似的元素）的居中。margin:0 auto是设置块元素（或与之类似的元素）的居中。 图片的水平居中我们设置图片标签img {margin:0 auto;} ，我们就犯了一个小错误，img类于内联对象，不可以设置图片img标签的margin属性，如果你一定想要设置，那么首先要将它的属性转变为块元素，如下面的代码： 1234img &#123; display:block; margin:0 auto;&#125; 3.在一个盒子里面，让一个有固定宽高的盒子实现水平居中：12display: block; /* 转化成为块级元素 */magin: auto; 4.绝对定位元素的居中实现123456.element &#123; width: 600px; height: 400px; position: absolute; left: 50%; top: 50%; margin-top: -200px; /* 高度的一半 */ margin-left: -300px; /* 宽度的一半 */&#125; 上面的写法需要严格知道盒子的宽高(局限性)，所以有了下面的写法(手机web开发可忽略,E10+以及其他现代浏览器才支持) 12345.element &#123; width: 600px; height: 400px; position: absolute; left: 50%; top: 50%; transform: translate(-50%, -50%); /* 50%为自身尺寸的一半 */&#125; 总结下 ，margin:auto实现绝对定位元素的居中（水平垂直居中） 123456.element &#123; width: 600px; height: 400px; position: absolute; left: 0; top: 0; right: 0; bottom: 0; margin: auto; /* 有了这个就自动居中了 */&#125; 垂直居中1.若元素是单行文本, 则可设置 line-height 等于父元素高度1234.element &#123; line-height: 10px; height:10px;&#125; 2.若元素是行内块级元素（行内元素的一种）123456.element &#123; height:10px; line-height:10px; display: inline-block; vertical-align: middle;&#125; 3.块级元素（元素高度固定）123456.element &#123; width: 600px; height: 400px; position: absolute; left: 0; top: 0; right: 0; bottom: 0; margin: auto; /* 有了这个就自动居中了 */&#125; 4.很普通的一种垂直居中12345678.parent::after, .son&#123; display:inline-block; vertical-align:middle; &#125; .parent::after&#123; content:''; height:100%; &#125; flex弹性布局实现水平垂直居中1.实现用flex布局的水平垂直居中特别方便，想要进一步了解Flex弹性布局请参考Flex 布局教程：语法篇和 Flex 布局教程：实例篇 flex的居中 12345.element &#123; .display: flex; align-items：center; /* 垂直方向上的对齐方式； */ justify-content：center; /* 水平方向上的对齐方式 */&#125; 但是用了flex布局后 有一些css属性会失效？ 2.存在的问题2.1 当一个块级元素要实现垂直居中(文本过短时)，和上下滚动(文本过长时)这种场景的时候往往会出现问题. 12345&lt;div class="div-bottom"&gt; &lt;div class="div-bottom-1"&gt; 水平垂直居下~~~~水平垂直居下~~~~ &lt;/div&gt;&lt;/div&gt; 1234567891011121314.div-bottom &#123; display: flex; height: 50%; flex-direction: column; justify-content: center; align-items: center; overflow: auto;&#125;.div-bottom-1 &#123; margin: auto; display: flex; margin: auto;&#125; 2.2 align-items：center;(垂直)和justify-content：center;(水平)的居中方向有的时候会相反？ flex布局有主轴和辅轴的概念。]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>样式布局</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[GitHub Pages自定义域名]]></title>
    <url>%2F2018%2F03%2F28%2Ftools%2Fgit%2Fgithub-page%2F</url>
    <content type="text"><![CDATA[简介现在有很多的前端开发者用XXX.github.io作为自己的博客，然后绑定到自己的域名上面，感觉起来挺不错。一、不用花钱买服务器了，二、一套流程下来前端完全可以搞定。部署完成是这样的 niceboybao.github.io niceboybao.com 有创意的小伙伴还可以用现在流行的三大框架(angular,react,或者vue)构建自己的博客工程呢，这一块我也在着手开始，在工作的业余时间，让自己变得更充实！对没错，生活不止眼前的苟且 还有诗和远方。下面开始正式环节，以niceboybao为例！ 主要参考资料Using a custom domain with GitHub Pages 用阿里云免费ssl证书把网站从http变成https 配置 niceboybao.github.io创建repository首先需要在GitHub上面创建一个repository，并且命名为niceboybao.github.io。 添加CNAME文件小伙伴可以把repository克隆下来，在repository下创建一个CNAME文件,文件名大写且没有后缀，如下图。文件里面添加需要绑定的域名，注意没有www和https前缀。 settings然后到repository的设置页面设置将自己的仓库发布到网站上面，并且添加上域名 如图： 域名解析现在挺流行的阿里云，我这边用阿里云举例，首先要找到自己购买的域名（控制台-&gt;域名与网站(万网)-&gt;域名-&gt;解析）然后配置下面2步 第一步，@符号的是指定你的域名xxx.com映射到xxx.github.io，第二布，www那一条是指定你的主域名www.xxx.com映射到xxx.github.io。这边看别人配置的时候都说一定不要忘记`xxx.github.io.`后面的`.`，可是好像加上去了没效果，不知道有没有小伙伴遇到过呢！ 配置完了勾选点击启动就ok啦！要全球解析生效，好像得等上一会了。后面就开始你们的表演吧，用自己熟悉的框架开发一个属于自己的blogs吧！niceboybao.com 另外，在GitHub上面的仓库只要在settings里面把他们发布到网站上面，就可以用niceboybao.com/xxx（xxx表示仓库名）访问到如：valentines_day。 用阿里云免费ssl证书把网站从http变成https HTTP 协议是不加密传输数据的，也就是用户跟你的网站之间传递数据有可能在途中被截获，破解传递的真实内容，所以使用不加密的 HTTP 的网站是不太安全的。所以， Google 的 Chrome 浏览器将在 2017 年 1 月开始，标记使用不加密的 HTTP 协议的网站为 Not Secure，不安全。 登录阿里云后台，找到，产品与服务-》找到证书服务，购买证书 找到免费型的DV SSL 购买后在订单页面点击补全，输入你的域名，如xxx.com，最后提交审核。当证书是已签发状态时，就可下载。]]></content>
      <categories>
        <category>博客配置</category>
      </categories>
      <tags>
        <tag>github</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[前端规范篇（一）]]></title>
    <url>%2F2018%2F03%2F27%2Fstandard%2Fstandard-0328%2F</url>
    <content type="text"></content>
      <categories>
        <category>前端规范</category>
      </categories>
      <tags>
        <tag>前端规范</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo docs]]></title>
    <url>%2F2018%2F03%2F26%2Ftools%2Fhexo%2Fhow-to-hexo-site%2F</url>
    <content type="text"><![CDATA[Hexo 配置一个优雅的博客参考链接 NexT开始使用教程 NexT主题配置教程 Hexo 中文文档 搭建个人博客-hexo+github详细完整步骤 step1 安装git,node.js和hexo1npm install -g hexo step2 初始化Hexo新建一个hexo的文件夹，在当前文件件下面执行：1hexo init 在_config.yml,进行基础配置 配置主题这里可以浏览更多主题,这里以NexT主题为例 1git clone https://github.com/iissnan/hexo-theme-next themes/next 本地浏览博客123hexo cleanhexo ghexo s step3 部署到GitHub上在自己的GitHub上面新建一个name.github.io仓库，有的话就不用新建了图片 在_config.yml进行配置123deploy: type: git repo: https://github.com/niceboybao/niceboybao.github.io.git 安装hexo-deployer-git自动部署发布工具1npm install hexo-deployer-git --save 发布到Github1hexo clean &amp;&amp; hexo g &amp;&amp; hexo d 发布完成输入niceboybao.github.io就可以访问 更多Hexo命令更多Hexo常用命令 12hexo new &quot;postName&quot; //新建文章hexo new page &quot;pageName&quot; //新建页面 stpex 配置时遇到的问题阅读次数统计的问题记录文章访问量的唯一标识符是文章的发布日期以及文章的标题，因此请确保这两个数值组合的唯一性，如果你更改了这两个数值，会造成文章阅读数值的清零重计。]]></content>
      <categories>
        <category>博客配置</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World Hexo]]></title>
    <url>%2F2018%2F03%2F25%2Ftools%2Fhexo%2Fhello-world-hexo%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
      <categories>
        <category>博客配置</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
</search>
