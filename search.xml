<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[TSX回调中必须注意的 this 指向]]></title>
    <url>%2F2018%2F04%2F10%2Freact%2Fjsx-class-this%2F</url>
    <content type="text"><![CDATA[简介class关键字基本上，ES6 的class可以看作只是一个语法糖，它的绝大部分功能，ES5 都可以做到，新的class写法只是让对象原型的写法更加清晰、更像面向对象编程的语法而已。上面的代码用 ES6 的class改写，就是下面这样。 123456789101112131415161718192021222324class Toggle extends React.Component &#123; constructor(props) &#123; super(props); this.state = &#123;isToggleOn: true&#125;; // 这个绑定是必要的，使`this`在回调中起作用 this.handleClick = this.handleClick.bind(this); &#125; handleClick() &#123; this.setState(prevState =&gt; (&#123; isToggleOn: !prevState.isToggleOn &#125;)); &#125; render() &#123; return ( &lt;button onClick=&#123;this.handleClick&#125;&gt; &#123;this.state.isToggleOn ? 'ON' : 'OFF'&#125; &lt;/button&gt; ); &#125;&#125;]]></content>
      <categories>
        <category>react</category>
      </categories>
      <tags>
        <tag>react技术栈</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Airbnb React/JSX 编码规范]]></title>
    <url>%2F2018%2F04%2F10%2Freact%2Freact-jsx-style-guide%2F</url>
    <content type="text"><![CDATA[简介 参考 Airbnb React/JSX Style Guide 算是最合理的React/JSX编码规范之一了。 Create创建模块如果你的模块有内部状态或者是refs, 推荐使用 class extends React.Component 而不是 React.createClass。 123456789101112131415// badconst Listing = React.createClass(&#123; // ... render() &#123; return &lt;div&gt;&#123;this.state.hello&#125;&lt;/div&gt;; &#125;&#125;);// goodclass Listing extends React.Component &#123; // ... render() &#123; return &lt;div&gt;&#123;this.state.hello&#125;&lt;/div&gt;; &#125;&#125; 如果你的模块没有状态或是没有引用refs， 推荐使用普通函数（非箭头函数）而不是类: 12345678910111213141516// badclass Listing extends React.Component &#123; render() &#123; return &lt;div&gt;&#123;this.props.hello&#125;&lt;/div&gt;; &#125;&#125;// bad (relying on function name inference is discouraged)const Listing = (&#123; hello &#125;) =&gt; ( &lt;div&gt;&#123;hello&#125;&lt;/div&gt;);// goodfunction Listing(&#123; hello &#125;) &#123; return &lt;div&gt;&#123;hello&#125;&lt;/div&gt;;&#125; Naming 命名 文件名: 文件名使用帕斯卡命名. 如, ReservationCard.jsx. 引用命名: React模块名使用帕斯卡命名，实例使用骆驼式命名. 1234567891011// badimport reservationCard from './ReservationCard';// goodimport ReservationCard from './ReservationCard';// badconst ReservationItem = &lt;ReservationCard /&gt;;// goodconst reservationItem = &lt;ReservationCard /&gt;; 模块命名: 模块使用当前文件名一样的名称. 比如 ReservationCard.jsx 应该包含名为 ReservationCard的模块. 但是，如果整个文件夹是一个模块，使用 index.js作为入口文件，然后直接使用 index.js 或者文件夹名作为模块的名称: 12345678// badimport Footer from './Footer/Footer';// badimport Footer from './Footer/index';// goodimport Footer from './Footer'; 属性命名: 避免使用DOM相关的属性来用作其他的用途。 12345// bad&lt;MyComponent style="fancy" /&gt;// good&lt;MyComponent variant="fancy" /&gt; Alignment 代码对齐1234567891011121314151617181920// bad&lt;Foo superLongParam="bar" anotherSuperLongParam="baz" /&gt;// good, 有多行属性的话, 新建一行关闭标签&lt;Foo superLongParam="bar" anotherSuperLongParam="baz"/&gt;// 若能在一行中显示, 直接写成一行&lt;Foo bar="bar" /&gt;// 子元素按照常规方式缩进&lt;Foo superLongParam="bar" anotherSuperLongParam="baz"&gt; &lt;Quux /&gt;&lt;/Foo&gt; Quotes 单引号还是双引号 对于JSX属性值总是使用双引号(“), 其他均使用单引号(‘). 为什么? HTML属性也是用双引号, 因此JSX的属性也遵循此约定. 1234567891011// bad&lt;Foo bar='bar' /&gt;// good&lt;Foo bar="bar" /&gt;// bad&lt;Foo style=&#123;&#123; left: "20px" &#125;&#125; /&gt;// good&lt;Foo style=&#123;&#123; left: '20px' &#125;&#125; /&gt; Props 属性 JSX属性名使用骆驼式风格camelCase. 123456789// bad&lt;foo username="hello" phone_number="&#123;12345678&#125;"&gt;&lt;/foo&gt;// good&lt;foo username="hello" phonenumber="&#123;12345678&#125;"&gt;&lt;/foo&gt; 如果属性值为 true, 可以直接省略. 12345678910111213// bad&lt;Foo hidden=&#123;true&#125;/&gt;// good&lt;Foo hidden/&gt;// good&lt;Foo hidden /&gt; 避免使用数组的index来作为属性key的值，推荐使用唯一ID. 12345678910111213141516// bad&#123;todos.map((todo, index) =&gt; &lt;Todo &#123;...todo&#125; key=&#123;index&#125; /&gt;)&#125;// good&#123;todos.map(todo =&gt; ( &lt;Todo &#123;...todo&#125; key=&#123;todo.id&#125; /&gt;))&#125; 对于所有非必须的属性，总是手动去定义defaultProps属性. 1234567891011121314151617181920212223// badfunction SFC(&#123; foo, bar, children &#125;) &#123; return &lt;div&gt;&#123;foo&#125;&#123;bar&#125;&#123;children&#125;&lt;/div&gt;;&#125;SFC.propTypes = &#123; foo: PropTypes.number.isRequired, bar: PropTypes.string, children: PropTypes.node,&#125;;// goodfunction SFC(&#123; foo, bar, children &#125;) &#123; return &lt;div&gt;&#123;foo&#125;&#123;bar&#125;&#123;children&#125;&lt;/div&gt;;&#125;SFC.propTypes = &#123; foo: PropTypes.number.isRequired, bar: PropTypes.string, children: PropTypes.node,&#125;;SFC.defaultProps = &#123; bar: '', children: null,&#125;; 特别提醒：尽可能地筛选出不必要的属性。 1234567891011//goodrender() &#123; const &#123; irrelevantProp, ...relevantProps &#125; = this.props; return &lt;WrappedComponent &#123;...relevantProps&#125; /&gt;&#125;//badrender() &#123; const &#123; irrelevantProp, ...relevantProps &#125; = this.props; return &lt;WrappedComponent &#123;...this.props&#125; /&gt;&#125; Refs 总是在Refs里使用回调函数 123456789// bad&lt;Foo ref="myRef"/&gt;// good ???&lt;Foo ref=&#123;(ref) =&gt; &#123; this.myRef = ref; &#125;&#125;/&gt; Parentheses 括号 将多行的JSX标签写在 ()里 123456789101112131415161718192021// badrender() &#123; return &lt;MyComponent className="long body" foo="bar"&gt; &lt;MyChild /&gt; &lt;/MyComponent&gt;;&#125;// goodrender() &#123; return ( &lt;MyComponent className="long body" foo="bar"&gt; &lt;MyChild /&gt; &lt;/MyComponent&gt; );&#125;// good, 单行可以不需要render() &#123; const body = &lt;div&gt;hello&lt;/div&gt;; return &lt;MyComponent&gt;&#123;body&#125;&lt;/MyComponent&gt;;&#125; Methods 函数 当在 render() 里使用事件处理方法时，提前在构造函数里把 this 绑定上去 为什么? 在每次 render 过程中， 再调用 bind 都会新建一个新的函数，浪费资源. 123456789101112131415161718192021222324252627// badclass extends React.Component &#123; onClickDiv() &#123; // do stuff &#125; render() &#123; return &lt;div onClick=&#123;this.onClickDiv.bind(this)&#125; /&gt;; &#125;&#125;// goodclass extends React.Component &#123; constructor(props) &#123; super(props); this.onClickDiv = this.onClickDiv.bind(this); &#125; onClickDiv() &#123; // do stuff &#125; render() &#123; return &lt;div onClick=&#123;this.onClickDiv&#125; /&gt;; &#125;&#125; 在 render 方法中总是确保 return 返回值 123456789// badrender() &#123; (&lt;div /&gt;);&#125;// goodrender() &#123; return (&lt;div /&gt;);&#125; Object 定义对象的细节逗号问题 单行定义的对象结尾不要逗号： 12345// badconst a = &#123; k1: v1, k2: v2, &#125;;// goodconst a = &#123; k1: v1, k2: v2 &#125;; 多行定义的对象要保留逗号： 1234567891011// badconst b = &#123; k1: v1, k2: v2&#125;;// goodconst b = &#123; k1: v1, k2: v2,&#125;; 一次性初始化完全 不要声明之后又给对象添加新属性： 1234567// badconst a = &#123;&#125;;a.x = 3;// goodconst a = &#123; x: null &#125;;a.x = 3; 如果一定非要加请使用Object.assign： 12const a = &#123;&#125;;Object.assign(a, &#123; x: 3 &#125;);]]></content>
      <categories>
        <category>前端规范</category>
      </categories>
      <tags>
        <tag>前端规范</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[react技术栈整理]]></title>
    <url>%2F2018%2F04%2F09%2Freact%2Freact-stack-url%2F</url>
    <content type="text"><![CDATA[简介使用react开发需要掌握一套完整的react技术栈，下面简单归纳下，后续会不断更新！ 单列技术点总结篇 一个 react + redux 的完整项目 和 个人总结（react的生命周期） https://github.com/bailicangdu/react-pxq 现代 Web 开发–React 篇 https://github.com/wxyyxc1992/Web-Series/tree/master/React React.js 初学者应该知道的9件事 http://www.iteye.com/news/31748]]></content>
      <categories>
        <category>react</category>
      </categories>
      <tags>
        <tag>react技术栈</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[文档写作注意点]]></title>
    <url>%2F2018%2F04%2F09%2FREADME%2F</url>
    <content type="text"><![CDATA[简介关于阅读量 文档名不要乱更改，更改会重置文档阅读量 文件夹命名和路径的更改也会重置文档阅读量 date的更改会重置文档阅读量，update不会,title不会]]></content>
      <categories>
        <category>README</category>
      </categories>
      <tags>
        <tag>README</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[react的diff算法]]></title>
    <url>%2F2018%2F04%2F09%2Freact%2Fdiff%2F</url>
    <content type="text"><![CDATA[简介参考 https://segmentfault.com/a/1190000000606216]]></content>
      <categories>
        <category>react</category>
      </categories>
      <tags>
        <tag>react技术栈</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[操作数组的一些方法]]></title>
    <url>%2F2018%2F04%2F08%2Fjavascript%2Fhandle-array%2F</url>
    <content type="text"><![CDATA[操作数组的一些方法在实际的项目开发过程中，基于对象或者数组而开发是特别常见的，所以整理了下能操作数组的一些js方法。（包括ES6的） reduce()定义Array.prototype.reduce() 方法接收一个函数作为累加器，数组中的每个值（从左到右）开始缩减，最终计算为一个值。reduce() 可以作为一个高阶函数，用于函数的 compose。 语法 array.reduce(function(total, currentValue, currentIndex, arr), initialValue) 12345total: 必需。初始值, 或者计算结束后的返回值。currentValue: 必需。当前元素currentIndex: 可选。当前元素的索引arr: 可选。当前元素所属的数组对象。initialValue: 可选。传递给函数的初始值 实例计算所有count值的总和123456789101112131415161718192021222324252627const arr = &#123; "arr1": [&#123; "count": 10, "list": [&#123;&#125;, &#123;&#125;, &#123;&#125;, &#123;&#125;, &#123;&#125;, &#123;&#125;, &#123;&#125;, &#123;&#125;, &#123;&#125;, &#123;&#125;, &#123;&#125;, &#123;&#125;, &#123;&#125;, &#123;&#125;, &#123;&#125;, &#123;&#125;] &#125;, &#123; "count": 8, "list": [&#123;&#125;, &#123;&#125;, &#123;&#125;, &#123;&#125;, &#123;&#125;, &#123;&#125;, &#123;&#125;, &#123;&#125;, &#123;&#125;, &#123;&#125;, &#123;&#125;, &#123;&#125;, &#123;&#125;, &#123;&#125;, &#123;&#125;, &#123;&#125;] &#125;, &#123; "count": 7, "list": [&#123;&#125;, &#123;&#125;, &#123;&#125;, &#123;&#125;, &#123;&#125;, &#123;&#125;, &#123;&#125;, &#123;&#125;, &#123;&#125;, &#123;&#125;, &#123;&#125;, &#123;&#125;, &#123;&#125;, &#123;&#125;, &#123;&#125;, &#123;&#125;] &#125; ], "arr2": [&#123; "count": 7, "list": [&#123;&#125;, &#123;&#125;, &#123;&#125;, &#123;&#125;, &#123;&#125;, &#123;&#125;, &#123;&#125;, &#123;&#125;, &#123;&#125;] &#125;, &#123; "count": 9, "list": [&#123;&#125;, &#123;&#125;, &#123;&#125;, &#123;&#125;, &#123;&#125;, &#123;&#125;, &#123;&#125;, &#123;&#125;, &#123;&#125;, &#123;&#125;, &#123;&#125;, &#123;&#125;, &#123;&#125;, &#123;&#125;, &#123;&#125;, &#123;&#125;] &#125; ]&#125;;let countFun = arr.arr1.reduce((total, item) =&gt; &#123; return total + item.count;&#125;, 0); reduce 的其他实例 ？？待补充Object.keys()定义Object.keys() 方法会返回一个由一个给定对象的自身可枚举属性组成的数组，数组中属性名的排列顺序和使用 for…in 循环遍历该对象时返回的顺序一致 （两者的主要区别是 一个 for-in 循环还会枚举其原型链上的属性）。 语法 Object.keys(obj) 实例ES6 (for in) (for of) (forEach)Map/Setfind()/findIndex()map()Array.prototype.map() 方法创建一个新数组，其结果是该数组中的每个元素都调用一个提供的函数后返回的结果。 语法 array.map(function(currentValue,index,arr), thisValue) 12345currentValue: 必须。当前元素的值currentValue: 可选。当期元素的索引值currentValue: 可选。当期元素属于的数组对象currentValue: 可选。对象作为该执行回调时使用，传递给函数，用作 "this" 的值。如果省略了 thisValue ，"this" 的值为 "undefined" 实例jsx语法中，遍历循环的话使用map的情况特别多。 12345//map()的简单使用let arr = [1, 2, 3, 4, 5];let mapArr = arr.map((item, index) =&gt; &#123; return item * item;&#125;); 数组拼接的一些方法concat()定义concat() 方法用于连接两个或多个数组。该方法不会改变现有的数组，而仅仅会返回被连接数组的一个副本。 语法 arrayObject.concat(arrayX,arrayX,……,arrayX) 1arrayX: 必需。该参数可以是具体的值，也可以是数组对象。可以是任意多个。 实例12const a = [1,2,3];let b = a.concat(4,5); //[1,2,3,4,5] join()[…]数组截取的一些方法splice()fill() 方法定义Array.prototype.fill()方法用一个固定值填充一个数组中从起始索引到终止索引内的全部元素。 语法 array.fill(value, start, end) 123value: 必需。填充的值。start: 可选。开始填充位置。(下标从1开始)end: 可选。停止填充位置 (默认为 array.length) 实例12var fruits = ["Banana", "Orange", "Apple", "Mango"];fruits.fill("Runoob", 2, 4); //Banana,Orange,Runoob,Runoob 12new Array(5).fill(0); //[0, 0, 0, 0, 0]new Array(5).fill(false); // [false, false, false, false, false]]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>Array</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[简历01]]></title>
    <url>%2F2018%2F04%2F08%2Fmine%2Finterview%2Fresume0408%2F</url>
    <content type="text"><![CDATA[简介我的前端面试简历 教育背景主修课程: phyon，C 语言，C++数据结构与算法，Java 基础，编译原理，计算机组成原理, 操作系统原理，计算机网络原 理，html 和 css 基础，JavaScript，php，SQL，大学英语，高数 个人技能 熟悉前端基础知识 html5，css3 等，熟悉 JavaScript，jQuery; 熟悉页面架构和布局(栅格布局，响应式布局，弹性布局)，熟悉 css 的扩展语言 Sass，Less 的基本用法; 熟悉 W3C 标准，理解各主流浏览器间的兼容性问题，有强烈的前端性能优化意识; 了解 JavaScript 语言的标准 ES5，ES6。熟悉面向对象编程，学习过 typescript 等强类型语言; 熟悉一些前端工程化打包工具，如 gulp，webpack; 了解 cordova 基本插件以及打包方式; 7.熟悉一些口语测评插件，如科大讯飞，云知声等插件的录音、上传、测评等 API; 熟悉前端 UI 框架 onsenui，angular material，ant design; 熟悉 svn，git，gitlab 等开发工具，开发过程中使用过 Tower，sourceTree 等工具，平时会在 GitHub 上整理一些小东西; 熟悉 angularjs 框架，能够搭建一个 angularjs+webpack+onsen+ES6+cordova 的前端工程; 熟悉 react 框架，能够搭建一个 react+webpack+antd+redux 的前端工程; 具备良好的学习能力、沟通能力、分析能力、bug 快速定位能力及解决问题能力; 对前端工程规范，代码标准规范，开发性能等期望很大，并在不断学习和提升; 工作态度很好，积极乐观，责任心强，喜欢不断学习和提升。 工作经验2015-10-23 至 2015-12-24—–上海汉得信息技术股份有限公司——培训生(实习) 知识点:java spring，SQL，PLSQL，oracle 公司去学校几轮面试后来到公司还是以培训为主，在此期间主要了解过javaspring，SQL，PLSQL，oracle 数据库和公司内部框架(oraler),然后参与公司内部框架的维护和搭建 知识点:css，JavaScript，JQ 这是我参与的第一个前端项目，主要任务是公司招聘网站开发，然后做一些页面，动画，和小逻辑，后期以 bug 修复为主。主要用到技术是 javaweb，JQ 等。 2016-03-07 至 2017-04-07—–上海汉得信息技术股份有限公司——前端开发工程师 知识点:angularjs+cordova+onsenui+gulp+es6 该工程主要是用前端流行框架 angularjs 搭建的学生端 APP 以及 PC 端答题模板页面从 js 到 angularjs 的改版， 使用 webpack，gulp 打包工具搭建 cordova 的 android 以及 ios 平台打包，最 终发布到各大 android 软件下载 网站以及 ios 的 appstore 供用户下载使用，该项目使用了 svn 后面使 用 gitlab 来管理工程代码的开发。 我主要负责多种题型下用户预览，答题，提交等各种交互的逻辑处理， 以及答题模板页面从 app 到 pc 的响应式布局的开发与搭建;解决 android 各种机型，ios 各版本以及 pc 浏览器兼容性 bug;以及后面功能点的不断迭代开发。改项目过程中，对打包插件 cordova 有一定的了 解，如手机的各种访问权限设置，头像上传等。 2016-06-07 至 2016-09-01—–上海汉得信息技术股份有限公司——前端开发工程师 知识点:前端工程规范和优化 改项目主要是针对前面开发过的 angularjs 项目做的一个前端优化项目，引入了强类型语言 typescript，提 高代码的严谨性;总结了一套前端工程和代码规范并实施;同时也对内存问题做了一些优化，利用 google 的调试工具 Memory 捕获内存快照和分析，一定程度的解决了内存泄漏问题。 2017-04-07 至 今—–上海汉得信息技术股份有限公司——前端开发工程师 知识点:react+webpack+redux+antd+saga+es6 该工程主要是用前端流行框架 reactjs 搭建的教师端 APP 以及 PC 端的项目。使用 react 框架以及 react-reduax，react-saga，react-router 等一系列中间件实现教师端 app 以及 pc 端的功能开发，其中 使用了 webpack 代码管理工具以及包管理工具 npm，用 cordova 搭建 ios 和 android 平台打包发布， 期间学会了使用 jenkinsfile 自动打包发布程序代码，该项目使用了 git 来管理工程代码的开发。 我主要负责的是 app 和 pc 教师布置作业的一条流程，题型组件开发好之后，我把他们整合起来实现教师布 置，预览，加题，换题，删题，布置和发布的一系列流程;同时也负责一种题型组件的开发;在此期间，担 任一次迭代项目的组长，并积极吧项目推上线。 2017-11-15 至 2018-01-15—–上海汉得信息技术股份有限公司——前端开发工程师 知识点: createjs，JavaScript，JQuery，gulp，H5 学习包项目:这个项目历时2个月，是我主导的一个游戏开发项目，主要是用createjs实现多个游戏的开发， 并且还有很多超炫的动画和 UI。主要技术:createjs，JQuery，gulp，H5。项目前期主要和产品沟通确认 所有需求，然后根据需求在技术方面和总监考虑项目使用技术。确定下来后，就开始将难点一一罗列，分工 研究和实现，做出项目任务量和难点的排期汇报给领导，然后将任务分配到人和天，通过过进度和开会的方 法共同解决一些棘手问题，直到项目上线。 获得证书 英语 4，6 级证书;国家计算机 2 级证书;国家励志奖学金(2 次) 个人评价 本人从实习开始到现在，从事前端开发2年多了。虽然最最开始的时候自己是弱鸡，但是上进心大，责任心强，关键肯吃苦，很多项目都是按时或者提前完成。并且有时候主动要求一些重难点的任务。工作期间喜欢问，喜欢和同事和领导讨论技术问题，平时也喜欢去GitHub粉一些大佬，追求一些优雅的编程风格，很多东西都喜欢问为什么，喜欢问XX标准XX规范是怎么来的。所以喜欢在编程世界里面探索！]]></content>
      <categories>
        <category>我的</category>
      </categories>
      <tags>
        <tag>简历</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[致年轻的自己]]></title>
    <url>%2F2018%2F04%2F08%2Fmine%2Fpower%2Fyoung-self%2F</url>
    <content type="text"><![CDATA[致年轻的自己20-30岁你拿这十年做什么？ [尴尬]篇20多岁的尴尬，是迷茫，是害怕；是才华配不上梦想；是付出配不上野心；是现实与生活的较量。 [苦才是人生]篇矛盾说，我从来不梦想，我只是在努力认识现实；洪深说，我的梦想是明年吃苦比今年更强；鲁迅说，人生最大的痛苦是梦醒了无路可走！]]></content>
      <categories>
        <category>我的</category>
      </categories>
      <tags>
        <tag>谁的清楚不迷茫</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[做了一年的react自己的感悟和总结]]></title>
    <url>%2F2018%2F04%2F04%2Freact%2Freact-think%2F</url>
    <content type="text"><![CDATA[简介react确实是一个神奇而优雅的框架。在从事react项目之前，一直是在做angular的，angular是一个全面和庞大的框架，在起初设计的时候什么都有，复杂程度也很高，所以用angular做项目基本上不需要其他的辅助库来配合。但是react项目真的是不一样了，要是只会一个react的话，很难开发出需求的。因为react就只负责UI的渲染。 做react项目需要掌握什么react 功能单一用于UI渲染，redux 用来管理数据，react-router 用来管理路由，webpack 用来配置工程，ES6 让代码更加优雅，redux-saga 用来处理异步请求，reselect 缓存机制用来减少state改变带来的渲染压力,还有一些为了交互衍生出来的中间件 react-redux、react-router-redux、react-router-dom ，预处理器Sass或Less 尽量也掌握下。 react 前面有说过react只负责ui的渲染 从V-dom出发react最难能可贵的就是虚拟dom的思想，这里有个贴切的比喻：把dom和JavaScript想象为各自的2个岛屿，中间有桥梁相连，但是桥上设有收费站，JavaScript去访问dom岛屿的次数越多，费用就越高。这就是一个js操作dom的过程，也许我们经常听到或者看到说尽量少的去操作dom，很耗性能。但是DOM 操作成本到底高在哪儿？,这边小总结下： 从输入uri到页面加载好是一个很漫长的过程，我们就从html的解析开始说起。①解析HTML，开始构建DOM树；②解析CSS，生成CSS规则树；③合并DOM树和CSS规则树，生成render树；④布局render树（Layout/reflow），这时候负责元素尺寸大小，位置的计算，属于js中回流过程；⑤绘制render树（paint），绘制页面像素，属于重绘的过程；⑥浏览器会将各层的信息发送给GPU(图像处理器)，GPU将各层合成（composite），显示在屏幕上。这是初始化渲染的过程，通过js操作DOM后，会引起 回流 和重绘，回流的成本很高，一个节点的回流会导致兄弟节点和子节点的回流，这样就一直在消耗GPU资源，所以才有了成本高的说法。 我们从操作dom的成本开始引入react，它创造了虚拟dom并且将它们储存起来，每当状态发生变化的时候就会创造新的虚拟节点和以前的进行对比，让变化的部分进行渲染。整个过程没有对dom进行获取和操作，只有等真正render时，才会去操作真实dom，从而引发页面的渲染。 diff算法react的diff算法用在什么地方呢？当组件更新的时候，react会创建一个新的虚拟dom树并且会和之前储存的dom树进行比较，这个比较多过程就用到了diff算法，所以组件初始化的时候是用不到的。react提出了一种假设，相同的节点具有类似的结构，而不同的节点具有不同的结构。在这种假设之上进行逐层的比较，如果发现对应的节点是不同的，那就直接删除旧的节点以及它所包含的所有子节点然后替换成新的节点。如果是相同的节点，则只进行属性的更改。 对于列表的diff算法稍有不同，因为列表通常具有相同的结构，在对列表节点进行删除，插入，排序的时候，单个节点的整体操作远比一个个对比一个个替换要好得多，所以在创建列表的时候需要设置key值，这样react才能分清谁是谁。当然不写key值也可以，但这样通常会报出警告，通知我们加上key值以提高react的性能。 需要了解清楚，看源码 单项数据流 组件化组件就是拥有独立功能的视图模块,React的最大好处在于：功能组件化，遵守前端可维护的原则。 组件生命周期 组件初始化会触发的5个钩子函数1.getDefaultProps() 设置默认的props，也可以用defaultProps设置组件的默认属性。 getDefaultProps相当于ES6中的 static defaultProps = {} 2.getInitialState() 在使用es6的class语法时是没有这个钩子函数的，可以直接在constructor中定义this.state。此时可以访问this.props。 getInitialState相当于ES6 class中constructor的 this.state = {} 钩子函数1 2 只有用React.createClass方法创造的组件类才会发生作用，并且React.createClass已经被Fb官方废弃，所以这里不细讲了。 3.componentWillMount() 组件初始化时只调用，以后组件更新不调用，整个生命周期只调用一次，此时可以修改state。 4.render() react最重要的步骤，创建虚拟dom，进行diff算法，更新dom树都在此进行。 render() 应该是一个纯函数，完全根据state和props来决定返回结果，而不产生副作用，所以render中调用setState是错的，因为纯函数不应该引起状态的改变 5.componentDidMount() 组件渲染之后调用，可以通过this.getDOMNode()获取和操作dom节点，只调用一次。 did的前缀表示进入状态之后调用，比如componentDidMount，组件一般初始化都会在这里进行数据请求。 组件交互更新时触发的5个钩子函数6.componentWillReceiveProps(nextProps) 组件初始化时不调用，组件接受新的props时调用。 开发过程中一般是在这个钩子函数里面改变state,此方法中改变state不会二次渲染而是进行state合并。 7.shouldComponentUpdate(nextProps, nextState) react性能优化非常重要的一环。组件接受新的state或者props时调用，我们可以设置在此对比前后两个props和state是否相同，如果相同则返回false阻止更新，因为相同的属性状态一定会生成相同的dom树，这样就不需要创造新的dom树和旧的dom树进行diff算法对比，节省大量性能，尤其是在dom结构复杂的时候。不过调用this.forceUpdate会跳过此步骤。 8.componentWillUpdate(nextProps, nextState) 组件初始化时不调用，只有在组件将要更新时才调用。 千万不要在这个函数中调用this.setState()方法，会造成循环调用。 9.render() 同上render()，创建虚拟dom，进行diff算法，更新dom树都在此进行。 10.componentDidUpdate() 组件初始化时不调用，组件更新完成后调用，此时可以获取dom节点。 在componentDidUpdate后才能获取更新后的this.state。如果想获取组件默认的props，并且赋值给State ,就可以在这里修改，达到UI上的效果。 组件卸载时调用10.componentWillUnmount() 组件将要卸载时调用，一些事件监听和定时器需要在此时清除,还有此组件store上面的值也可以对应的清楚。 componentWillUnmount执行重置所有相关参数。在该方法中调用setState不会触发render，因为所有的更新队列，更新状态都被重置为null。 123456789//数据清楚需要写在reducer里面this.props.clearPointData();[CLEAR_POINT_DATA]: (state, action: Action&lt;any&gt;) =&gt; &#123; return Object.assign(&#123;&#125;, state, &#123; selectedReadingList: &#123;&#125;, knowledgePoint: &#123;&#125;, &#125;);&#125; 以上可以看出来react总共有10个周期函数（render重复一次），这个10个函数可以满足我们所有对组件操作的需求，利用的好可以提高开发效率和组件性能。 reduxreact-reduxreact-router要了解下router的机制 react-router-redux保持路由与应用状态（state）同步。使用redux管理应用状态(state)，使用router管理路由，两个库不能协同工作，react-router-redux库可以协调这两个库。 react-router-domredux-sagareselectES6webpack参考webpack官网 Sass or Less随着前端的不断发展，网站的页面复杂度也在不断提升，原生 CSS 已经让开发者力不从心，预处理器赋予我们的 “超能力”。浅谈 CSS 预处理器：为什么要使用预处理器？ Sass参考Sass语法 Less参考Less语法]]></content>
      <categories>
        <category>react</category>
      </categories>
      <tags>
        <tag>react技术栈</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[平时整理的css水平垂直居中]]></title>
    <url>%2F2018%2F03%2F28%2Flayout%2Fcss-center%2F</url>
    <content type="text"><![CDATA[水平垂直居中Learn more here掘金-CSS的垂直居中和水平居中总结 16种方法实现水平居中垂直居中 水平居中1.行内元素（inline element）, 给其父元素设置 text-align:center （适用行内元素）什么是行内元素，块级元素 12inline element也叫内联元素、内嵌元素等；行内元素一般都是基于语义级(semantic)的基本元素，只能容纳文本或其他内联元素，常见内联元素 “a”。比如 SPAN 元素，IFRAME元素和元素样式的display : inline的都是行内元素。 2.块级元素（block element）, 该元素设置 margin:0 auto即可.只有块级元素才生效（让整个块元素居中）margin 0 auto与text-align:center的区别 1text-align:center设置为文本或img标签等一些内联对象（或与之类似的元素）的居中。margin:0 auto是设置块元素（或与之类似的元素）的居中。 图片的水平居中我们设置图片标签img {margin:0 auto;} ，我们就犯了一个小错误，img类于内联对象，不可以设置图片img标签的margin属性，如果你一定想要设置，那么首先要将它的属性转变为块元素，如下面的代码： 1234img &#123; display:block; margin:0 auto;&#125; 3.在一个盒子里面，让一个有固定宽高的盒子实现水平居中：12display: block; /* 转化成为块级元素 */magin: auto; 4.绝对定位元素的居中实现123456.element &#123; width: 600px; height: 400px; position: absolute; left: 50%; top: 50%; margin-top: -200px; /* 高度的一半 */ margin-left: -300px; /* 宽度的一半 */&#125; 上面的写法需要严格知道盒子的宽高(局限性)，所以有了下面的写法(手机web开发可忽略,E10+以及其他现代浏览器才支持) 12345.element &#123; width: 600px; height: 400px; position: absolute; left: 50%; top: 50%; transform: translate(-50%, -50%); /* 50%为自身尺寸的一半 */&#125; 总结下 ，margin:auto实现绝对定位元素的居中（水平垂直居中） 123456.element &#123; width: 600px; height: 400px; position: absolute; left: 0; top: 0; right: 0; bottom: 0; margin: auto; /* 有了这个就自动居中了 */&#125; 垂直居中1.若元素是单行文本, 则可设置 line-height 等于父元素高度1234.element &#123; line-height: 10px; height:10px;&#125; 2.若元素是行内块级元素（行内元素的一种）123456.element &#123; height:10px; line-height:10px; display: inline-block; vertical-align: middle;&#125; 3.块级元素（元素高度固定）123456.element &#123; width: 600px; height: 400px; position: absolute; left: 0; top: 0; right: 0; bottom: 0; margin: auto; /* 有了这个就自动居中了 */&#125; 4.很普通的一种垂直居中12345678.parent::after, .son&#123; display:inline-block; vertical-align:middle; &#125; .parent::after&#123; content:''; height:100%; &#125; flex弹性布局实现水平垂直居中1.实现用flex布局的水平垂直居中特别方便，想要进一步了解Flex弹性布局请参考Flex 布局教程：语法篇和 Flex 布局教程：实例篇 flex的居中 12345.element &#123; .display: flex; align-items：center; /* 垂直方向上的对齐方式； */ justify-content：center; /* 水平方向上的对齐方式 */&#125; 但是用了flex布局后 有一些css属性会失效？ 2.存在的问题2.1 当一个块级元素要实现垂直居中(文本过短时)，和上下滚动(文本过长时)这种场景的时候往往会出现问题. 12345&lt;div class="div-bottom"&gt; &lt;div class="div-bottom-1"&gt; 水平垂直居下~~~~水平垂直居下~~~~ &lt;/div&gt;&lt;/div&gt; 1234567891011121314.div-bottom &#123; display: flex; height: 50%; flex-direction: column; justify-content: center; align-items: center; overflow: auto;&#125;.div-bottom-1 &#123; margin: auto; display: flex; margin: auto;&#125; 2.2 align-items：center;(垂直)和justify-content：center;(水平)的居中方向有的时候会相反？ flex布局有主轴和辅轴的概念。]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>样式布局</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[GitHub Pages自定义域名]]></title>
    <url>%2F2018%2F03%2F28%2Ftools%2Fgit%2Fgithub-page%2F</url>
    <content type="text"><![CDATA[简介现在有很多的前端开发者用XXX.github.io作为自己的博客，然后绑定到自己的域名上面，感觉起来挺不错。一、不用花钱买服务器了，二、一套流程下来前端完全可以搞定。部署完成是这样的 niceboybao.github.io niceboybao.com 有创意的小伙伴还可以用现在流行的三大框架(angular,react,或者vue)构建自己的博客工程呢，这一块我也在着手开始，在工作的业余时间，让自己变得更充实！对没错，生活不止眼前的苟且 还有诗和远方。下面开始正式环节，以niceboybao为例！ 主要参考资料Using a custom domain with GitHub Pages 用阿里云免费ssl证书把网站从http变成https 配置 niceboybao.github.io创建repository首先需要在GitHub上面创建一个repository，并且命名为niceboybao.github.io。 添加CNAME文件小伙伴可以把repository克隆下来，在repository下创建一个CNAME文件,文件名大写且没有后缀，如下图。文件里面添加需要绑定的域名，注意没有www和https前缀。 settings然后到repository的设置页面设置将自己的仓库发布到网站上面，并且添加上域名 如图： 域名解析现在挺流行的阿里云，我这边用阿里云举例，首先要找到自己购买的域名（控制台-&gt;域名与网站(万网)-&gt;域名-&gt;解析）然后配置下面2步 第一步，@符号的是指定你的域名xxx.com映射到xxx.github.io，第二布，www那一条是指定你的主域名www.xxx.com映射到xxx.github.io。这边看别人配置的时候都说一定不要忘记`xxx.github.io.`后面的`.`，可是好像加上去了没效果，不知道有没有小伙伴遇到过呢！ 配置完了勾选点击启动就ok啦！要全球解析生效，好像得等上一会了。后面就开始你们的表演吧，用自己熟悉的框架开发一个属于自己的blogs吧！niceboybao.com 另外，在GitHub上面的仓库只要在settings里面把他们发布到网站上面，就可以用niceboybao.com/xxx（xxx表示仓库名）访问到如：valentines_day。 用阿里云免费ssl证书把网站从http变成https HTTP 协议是不加密传输数据的，也就是用户跟你的网站之间传递数据有可能在途中被截获，破解传递的真实内容，所以使用不加密的 HTTP 的网站是不太安全的。所以， Google 的 Chrome 浏览器将在 2017 年 1 月开始，标记使用不加密的 HTTP 协议的网站为 Not Secure，不安全。 登录阿里云后台，找到，产品与服务-》找到证书服务，购买证书 找到免费型的DV SSL 购买后在订单页面点击补全，输入你的域名，如xxx.com，最后提交审核。当证书是已签发状态时，就可下载。]]></content>
      <categories>
        <category>博客配置</category>
      </categories>
      <tags>
        <tag>github</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[前端规范篇（一）]]></title>
    <url>%2F2018%2F03%2F27%2Fstandard%2Fstandard-0328%2F</url>
    <content type="text"></content>
      <categories>
        <category>前端规范</category>
      </categories>
      <tags>
        <tag>前端规范</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo docs]]></title>
    <url>%2F2018%2F03%2F26%2Ftools%2Fhexo%2Fhow-to-hexo-site%2F</url>
    <content type="text"><![CDATA[Hexo 配置一个优雅的博客参考链接 NexT开始使用教程 NexT主题配置教程 Hexo 中文文档 搭建个人博客-hexo+github详细完整步骤 step1 安装git,node.js和hexo1npm install -g hexo step2 初始化Hexo新建一个hexo的文件夹，在当前文件件下面执行：1hexo init 在_config.yml,进行基础配置 配置主题这里可以浏览更多主题,这里以NexT主题为例 1git clone https://github.com/iissnan/hexo-theme-next themes/next 本地浏览博客123hexo cleanhexo ghexo s step3 部署到GitHub上在自己的GitHub上面新建一个name.github.io仓库，有的话就不用新建了图片 在_config.yml进行配置123deploy: type: git repo: https://github.com/niceboybao/niceboybao.github.io.git 安装hexo-deployer-git自动部署发布工具1npm install hexo-deployer-git --save 发布到Github1hexo clean &amp;&amp; hexo g &amp;&amp; hexo d 发布完成输入niceboybao.github.io就可以访问 更多Hexo命令更多Hexo常用命令 12hexo new &quot;postName&quot; //新建文章hexo new page &quot;pageName&quot; //新建页面 stpex 配置时遇到的问题阅读次数统计的问题记录文章访问量的唯一标识符是文章的发布日期以及文章的标题，因此请确保这两个数值组合的唯一性，如果你更改了这两个数值，会造成文章阅读数值的清零重计。]]></content>
      <categories>
        <category>博客配置</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World Hexo]]></title>
    <url>%2F2018%2F03%2F25%2Ftools%2Fhexo%2Fhello-world-hexo%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
      <categories>
        <category>博客配置</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
</search>
